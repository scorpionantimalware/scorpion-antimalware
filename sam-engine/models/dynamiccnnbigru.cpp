/**********************************************************************************/
/*                                                                                */
/* dynamiccnnbigru.cpp                                                            */
/*                                                                                */
/**********************************************************************************/
/*                                                                                */
/*    Scorpion Anti-malware is a free Open Source AI-powered Anti-malware         */
/*    framework for Researchers.                                                  */
/*                                                                                */
/*    Copyright (c) 2024-present  (see AUTHORS.md).                               */
/*                                                                                */
/*    This program is free software: you can redistribute it and/or modify        */
/*    it under the terms of the GNU General Public License as published by        */
/*    the Free Software Foundation, either version 3 of the License, or           */
/*    (at your option) any later version.                                         */
/*                                                                                */
/*    This program is distributed in the hope that it will be useful,             */
/*    but WITHOUT ANY WARRANTY; without even the implied warranty of              */
/*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               */
/*    GNU General Public License for more details.                                */
/*                                                                                */
/*    You should have received a copy of the GNU General Public License           */
/*    along with this program.  If not, see <https://www.gnu.org/licenses/>.      */
/*                                                                                */
/**********************************************************************************/

#include "dynamiccnnbigru.hpp"

#include <filesystem>

namespace fs = std::filesystem;

#include <iostream>

DynamicCNNBiGRU::DynamicCNNBiGRU() : run_options(nullptr), env(nullptr), session(nullptr) {}

DynamicCNNBiGRU::~DynamicCNNBiGRU() {
    if (DynamicCNNBiGRU::session) {
        delete DynamicCNNBiGRU::session;
        DynamicCNNBiGRU::session = nullptr;
    }

    if (DynamicCNNBiGRU::env) {
        delete DynamicCNNBiGRU::env;
        DynamicCNNBiGRU::env = nullptr;
    }

    if (DynamicCNNBiGRU::run_options) {
        delete DynamicCNNBiGRU::run_options;
        DynamicCNNBiGRU::run_options = nullptr;
    }
}

bool DynamicCNNBiGRU::init() {
    bool status {false};

    const std::string model_path {SAM_DYNAMIC_CNN_BIGRU_ONNX_MODELPATH};

    // TODO: Make sure the file is readable.
    if (!fs::exists(model_path)) {
        std::cout << "Error: Model file does not exist." << std::endl;
        return status;
    }
    
    std::wstring widestr {std::wstring(model_path.begin(), model_path.end())};
    const wchar_t* widecstr {widestr.c_str()};

    if (!DynamicCNNBiGRU::run_options) {
        DynamicCNNBiGRU::run_options = new Ort::RunOptions();
    }
    else {
        std::cout << "Warning: Run options is already initialized." << std::endl;
    }

    if (!DynamicCNNBiGRU::env) {
        // Use CPU
        DynamicCNNBiGRU::env = new Ort::Env();
    }
    else {
        std::cout << "Warning: Environment is already initialized." << std::endl;
    }

    if (!DynamicCNNBiGRU::session) {
        // Use CPU
        DynamicCNNBiGRU::session = new Ort::Session(*env, widecstr, Ort::SessionOptions{ nullptr });
    }
    else {
        std::cout << "Warning: Session is already initialized." << std::endl;
    }

    status = true;

    return status;
}

bool DynamicCNNBiGRU::classify(const std::vector<int>& tokenized_api_call_sequence, float& output) {
    bool status {false};

    if (!run_options || !env || !session) {
        std::cout << "Error: DynamicCNNBiGRU is not initialized." << std::endl;
        return status;
    }

    if (tokenized_api_call_sequence.size() != CNN_BIGRU_NUM_INPUT_ELEMENTS) {
        std::cout << "Error: Invalid input features." << std::endl;
        return status;
    }

    // define shape
    const std::array<int64_t, 2> input_shape {{ 1, CNN_BIGRU_NUM_INPUT_ELEMENTS }};
    const std::array<int64_t, 2> output_shape {{ 1, CNN_BIGRU_NUM_CLASSES }};

    // define array
    std::array<int, CNN_BIGRU_NUM_INPUT_ELEMENTS> input;
    std::array<float, CNN_BIGRU_NUM_CLASSES> results;

    // define Tensor
    auto memory_info {Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeCPU)};
    auto input_tensor {Ort::Value::CreateTensor<int>(memory_info, input.data(), input.size(), input_shape.data(), input_shape.size())};
    auto output_tensor {Ort::Value::CreateTensor<float>(memory_info, results.data(), results.size(), output_shape.data(), output_shape.size())};

    // copy image data to input array
    std::copy(tokenized_api_call_sequence.begin(), tokenized_api_call_sequence.end(), input.begin());

    // define names
    Ort::AllocatorWithDefaultOptions ort_alloc;
    Ort::AllocatedStringPtr input_name {session->GetInputNameAllocated(0, ort_alloc)};
    Ort::AllocatedStringPtr output_name {session->GetOutputNameAllocated(0, ort_alloc)};
    const std::array<const char*, 1> input_names {{ input_name.get()}};
    const std::array<const char*, 1> output_names {{ output_name.get()}};
    input_name.release();
    output_name.release();

    session->Run(
        *DynamicCNNBiGRU::run_options, 
        input_names.data(), 
        &input_tensor, 
        1, 
        output_names.data(), 
        &output_tensor, 
        1
    );

    output = results[0];

    status = true;

    return status;
}
