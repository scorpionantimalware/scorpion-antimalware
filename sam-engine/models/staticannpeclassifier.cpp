#include "staticannpeclassifier.h"

#include <filesystem>

namespace fs = std::filesystem;

#include <iostream>

StaticANNPEClassifier::StaticANNPEClassifier() : run_options(nullptr), env(nullptr), session(nullptr) {}

StaticANNPEClassifier::~StaticANNPEClassifier() {
    if (StaticANNPEClassifier::session) {
        delete StaticANNPEClassifier::session;
    }

    if (StaticANNPEClassifier::env) {
        delete StaticANNPEClassifier::env;
    }

    if (StaticANNPEClassifier::run_options) {
        delete StaticANNPEClassifier::run_options;
    }
}

bool StaticANNPEClassifier::init() {
    bool status {false};

    const std::string model_path {SAM_STATIC_ANN_ONNX_MODELPATH};

    // TODO: Make sure the file is readable.
    if (!fs::exists(model_path)) {
        std::cout << "Error: Model file does not exist." << std::endl;
        return status;
    }
    
    std::wstring widestr = std::wstring(model_path.begin(), model_path.end());
    const wchar_t* widecstr = widestr.c_str();

    if (!StaticANNPEClassifier::run_options) {
        StaticANNPEClassifier::run_options = new Ort::RunOptions();
    }
    else {
        std::cout << "Warning: Run options is already initialized." << std::endl;
    }

    if (!StaticANNPEClassifier::env) {
        // Use CPU
        StaticANNPEClassifier::env = new Ort::Env();
    }
    else {
        std::cout << "Warning: Environment is already initialized." << std::endl;
    }

    if (!StaticANNPEClassifier::session) {
        // Use CPU
        StaticANNPEClassifier::session = new Ort::Session(*env, widecstr, Ort::SessionOptions{ nullptr });
    }
    else {
        std::cout << "Warning: Session is already initialized." << std::endl;
    }

    status = true;

    return status;
}

bool StaticANNPEClassifier::classify(const std::vector<float>& input_features, float& output) {
    bool status {false};

    if (!run_options || !env || !session) {
        std::cout << "Error: StaticANNPEClassifier is not initialized." << std::endl;
        return status;
    }

    if (input_features.size() != NUM_INPUT_ELEMENTS) {
        std::cout << "Error: Invalid input features." << std::endl;
        return status;
    }

    // define shape
    const std::array<int64_t, 2> input_shape = { 1, NUM_INPUT_ELEMENTS };
    const std::array<int64_t, 2> output_shape = { 1, NUM_CLASSES };

    // define array
    std::array<float, NUM_INPUT_ELEMENTS> input;
    std::array<float, NUM_CLASSES> results;

    // define Tensor
    auto memory_info = Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeCPU);
    auto input_tensor = Ort::Value::CreateTensor<float>(memory_info, input.data(), input.size(), input_shape.data(), input_shape.size());
    auto output_tensor = Ort::Value::CreateTensor<float>(memory_info, results.data(), results.size(), output_shape.data(), output_shape.size());

    // copy image data to input array
    std::copy(input_features.begin(), input_features.end(), input.begin());

    // define names
    Ort::AllocatorWithDefaultOptions ort_alloc;
    Ort::AllocatedStringPtr input_name = session->GetInputNameAllocated(0, ort_alloc);
    Ort::AllocatedStringPtr output_name = session->GetOutputNameAllocated(0, ort_alloc);
    const std::array<const char*, 1> input_names = { input_name.get()};
    const std::array<const char*, 1> output_names = { output_name.get()};
    input_name.release();
    output_name.release();

    session->Run(
        *StaticANNPEClassifier::run_options, 
        input_names.data(), 
        &input_tensor, 
        1, 
        output_names.data(), 
        &output_tensor, 
        1
    );

    output = results[0];

    status = true;

    return status;
}
