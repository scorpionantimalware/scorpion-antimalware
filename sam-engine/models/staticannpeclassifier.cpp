/**
 *                        بِسْمِ اللَّهِ الرَّحْمَنِ الرَّحِيمِ
 * 
 * staticannpeclassifier.cpp
 * 
 * Copyright (c) 2024-present Scorpion Anti-malware (see AUTHORS.md).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 */

#include "staticannpeclassifier.hpp"

#include <filesystem>

namespace fs = std::filesystem;

#include <iostream>

StaticANNPEClassifier::StaticANNPEClassifier() : run_options(nullptr), env(nullptr), session(nullptr) {}

StaticANNPEClassifier::~StaticANNPEClassifier() {
    if (StaticANNPEClassifier::session) {
        delete StaticANNPEClassifier::session;
        StaticANNPEClassifier::session = nullptr;
    }

    if (StaticANNPEClassifier::env) {
        delete StaticANNPEClassifier::env;
        StaticANNPEClassifier::env = nullptr;
    }

    if (StaticANNPEClassifier::run_options) {
        delete StaticANNPEClassifier::run_options;
        StaticANNPEClassifier::run_options = nullptr;
    }
}

bool StaticANNPEClassifier::init() {
    bool status {false};

    const std::string model_path {SAM_STATIC_ANN_ONNX_MODELPATH};

    // TODO: Make sure the file is readable.
    if (!fs::exists(model_path)) {
        std::cout << "Error: Model file does not exist." << std::endl;
        return status;
    }
    
    std::wstring widestr {std::wstring(model_path.begin(), model_path.end())};
    const wchar_t* widecstr {widestr.c_str()};

    if (!StaticANNPEClassifier::run_options) {
        StaticANNPEClassifier::run_options = new Ort::RunOptions();
    }
    else {
        std::cout << "Warning: Run options is already initialized." << std::endl;
    }

    if (!StaticANNPEClassifier::env) {
        // Use CPU
        StaticANNPEClassifier::env = new Ort::Env();
    }
    else {
        std::cout << "Warning: Environment is already initialized." << std::endl;
    }

    if (!StaticANNPEClassifier::session) {
        // Use CPU
        StaticANNPEClassifier::session = new Ort::Session(*env, widecstr, Ort::SessionOptions{ nullptr });
    }
    else {
        std::cout << "Warning: Session is already initialized." << std::endl;
    }

    status = true;

    return status;
}

bool StaticANNPEClassifier::classify(const std::vector<float>& input_features, float& output) {
    bool status {false};

    if (!run_options || !env || !session) {
        std::cout << "Error: StaticANNPEClassifier is not initialized." << std::endl;
        return status;
    }

    if (input_features.size() != ANN_NUM_INPUT_ELEMENTS) {
        std::cout << "Error: Invalid input features." << std::endl;
        return status;
    }

    // define shape
    const std::array<int64_t, 2> input_shape {{ 1, ANN_NUM_INPUT_ELEMENTS }};
    const std::array<int64_t, 2> output_shape {{ 1, ANN_NUM_CLASSES }};

    // define array
    std::array<float, ANN_NUM_INPUT_ELEMENTS> input;
    std::array<float, ANN_NUM_CLASSES> results;

    // define Tensor
    auto memory_info {Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeCPU)};
    auto input_tensor {Ort::Value::CreateTensor<float>(memory_info, input.data(), input.size(), input_shape.data(), input_shape.size())};
    auto output_tensor {Ort::Value::CreateTensor<float>(memory_info, results.data(), results.size(), output_shape.data(), output_shape.size())};

    // copy image data to input array
    std::copy(input_features.begin(), input_features.end(), input.begin());

    // define names
    Ort::AllocatorWithDefaultOptions ort_alloc;
    Ort::AllocatedStringPtr input_name {session->GetInputNameAllocated(0, ort_alloc)};
    Ort::AllocatedStringPtr output_name {session->GetOutputNameAllocated(0, ort_alloc)};
    const std::array<const char*, 1> input_names {{ input_name.get()}};
    const std::array<const char*, 1> output_names {{ output_name.get()}};
    input_name.release();
    output_name.release();

    session->Run(
        *StaticANNPEClassifier::run_options, 
        input_names.data(), 
        &input_tensor, 
        1, 
        output_names.data(), 
        &output_tensor, 
        1
    );

    output = results[0];

    status = true;

    return status;
}
