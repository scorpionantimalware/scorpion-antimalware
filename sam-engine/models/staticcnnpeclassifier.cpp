/**********************************************************************************/
/*                                                                                */
/* staticcnnpeclassifier.cpp                                                      */
/*                                                                                */
/**********************************************************************************/
/*                                                                                */
/*    Scorpion Anti-malware is a free Open Source AI-powered Anti-malware         */
/*    framework for Researchers.                                                  */
/*                                                                                */
/*    Copyright (c) 2024-present  (see AUTHORS.md).                               */
/*                                                                                */
/*    This program is free software: you can redistribute it and/or modify        */
/*    it under the terms of the GNU General Public License as published by        */
/*    the Free Software Foundation, either version 3 of the License, or           */
/*    (at your option) any later version.                                         */
/*                                                                                */
/*    This program is distributed in the hope that it will be useful,             */
/*    but WITHOUT ANY WARRANTY; without even the implied warranty of              */
/*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               */
/*    GNU General Public License for more details.                                */
/*                                                                                */
/*    You should have received a copy of the GNU General Public License           */
/*    along with this program.  If not, see <https://www.gnu.org/licenses/>.      */
/*                                                                                */
/**********************************************************************************/

#include "staticcnnpeclassifier.hpp"

#include <filesystem>

namespace fs = std::filesystem;

#include <iostream>

StaticCNNPEClassifier::StaticCNNPEClassifier() : run_options(nullptr), env(nullptr), session(nullptr) {}

StaticCNNPEClassifier::~StaticCNNPEClassifier() {
    if (StaticCNNPEClassifier::session) {
        delete StaticCNNPEClassifier::session;
        StaticCNNPEClassifier::session = nullptr;
    }

    if (StaticCNNPEClassifier::env) {
        delete StaticCNNPEClassifier::env;
        StaticCNNPEClassifier::env = nullptr;
    }

    if (StaticCNNPEClassifier::run_options) {
        delete StaticCNNPEClassifier::run_options;
        StaticCNNPEClassifier::run_options = nullptr;
    }
}

bool StaticCNNPEClassifier::init() {
    bool status {false};

    const std::string model_path {SAM_STATIC_CNN_ONNX_MODELPATH};

    // TODO: Make sure the file is readable.
    if (!fs::exists(model_path)) {
        std::cout << "Error: Model file does not exist." << std::endl;
        return status;
    }
    
    std::wstring widestr {std::wstring(model_path.begin(), model_path.end())};
    const wchar_t* widecstr {widestr.c_str()};

    if (!StaticCNNPEClassifier::run_options) {
        StaticCNNPEClassifier::run_options = new Ort::RunOptions();
    }
    else {
        std::cout << "Warning: Run options is already initialized." << std::endl;
    }

    if (!StaticCNNPEClassifier::env) {
        // Use CPU
        StaticCNNPEClassifier::env = new Ort::Env();
    }
    else {
        std::cout << "Warning: Environment is already initialized." << std::endl;
    }

    if (!StaticCNNPEClassifier::session) {
        // Use CPU
        StaticCNNPEClassifier::session = new Ort::Session(*env, widecstr, Ort::SessionOptions{ nullptr });
    }
    else {
        std::cout << "Warning: Session is already initialized." << std::endl;
    }

    status = true;

    return status;
}

bool StaticCNNPEClassifier::classify(const std::vector<float>& input_features, float& output) {
    bool status {false};

    if (!run_options || !env || !session) {
        std::cout << "Error: StaticCNNPEClassifier is not initialized." << std::endl;
        return status;
    }

    if (input_features.size() != CNN_NUM_INPUT_ELEMENTS) {
        std::cout << "Error: Invalid input features." << std::endl;
        return status;
    }

    // define shape
    const std::array<int64_t, 4> input_shape {{ 1, NUM_CHANNELS, HEIGHT, WIDTH}};
    const std::array<int64_t, 2> output_shape {{ 1, CNN_NUM_CLASSES }};

    // define array
    std::array<float, CNN_NUM_INPUT_ELEMENTS> input;
    std::array<float, CNN_NUM_CLASSES> results;

    // define Tensor
    auto memory_info {Ort::MemoryInfo::CreateCpu(OrtDeviceAllocator, OrtMemTypeCPU)};
    auto input_tensor {Ort::Value::CreateTensor<float>(memory_info, input.data(), input.size(), input_shape.data(), input_shape.size())};
    auto output_tensor {Ort::Value::CreateTensor<float>(memory_info, results.data(), results.size(), output_shape.data(), output_shape.size())};

    // copy image data to input array
    std::copy(input_features.begin(), input_features.end(), input.begin());

    // define names
    Ort::AllocatorWithDefaultOptions ort_alloc;
    Ort::AllocatedStringPtr input_name  {session->GetInputNameAllocated(0, ort_alloc)};
    Ort::AllocatedStringPtr output_name  {session->GetOutputNameAllocated(0, ort_alloc)};
    const std::array<const char*, 1> input_names  {{ input_name.get()}};
    const std::array<const char*, 1> output_names  {{ output_name.get()}};
    input_name.release();
    output_name.release();

    session->Run(
        *StaticCNNPEClassifier::run_options, 
        input_names.data(), 
        &input_tensor, 
        1, 
        output_names.data(), 
        &output_tensor, 
        1
    );

    output = results[0];

    status = true;

    return status;
}
