/**********************************************************************************/
/*                                                                                */
/* dynamicsengine.cpp                                                             */
/*                                                                                */
/**********************************************************************************/
/*                                                                                */
/*    Scorpion Anti-malware is a free Open Source AI-powered Anti-malware         */
/*    framework for Researchers.                                                  */
/*                                                                                */
/*    Copyright (c) 2024-present  (see AUTHORS.md).                               */
/*                                                                                */
/*    This program is free software: you can redistribute it and/or modify        */
/*    it under the terms of the GNU General Public License as published by        */
/*    the Free Software Foundation, either version 3 of the License, or           */
/*    (at your option) any later version.                                         */
/*                                                                                */
/*    This program is distributed in the hope that it will be useful,             */
/*    but WITHOUT ANY WARRANTY; without even the implied warranty of              */
/*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               */
/*    GNU General Public License for more details.                                */
/*                                                                                */
/*    You should have received a copy of the GNU General Public License           */
/*    along with this program.  If not, see <https://www.gnu.org/licenses/>.      */
/*                                                                                */
/**********************************************************************************/

#include "dynamicsengine.hpp"

#include <filesystem>

namespace fs = std::filesystem;

#include <iostream>

#define CNN_BIGRU_API_CALL_SEQUENCE_MAXIMUM_LENGTH 120

DynamicsEngine::DynamicsEngine() :
		pModule(nullptr), pFunc(nullptr) {
}

DynamicsEngine::~DynamicsEngine() {
	if (DynamicsEngine::pFunc) {
		// Release the reference to the function object
		Py_DECREF(DynamicsEngine::pFunc);
	}

	if (DynamicsEngine::pModule) {
		// Release the reference to the module object
		Py_DECREF(DynamicsEngine::pModule);
	}
}

bool DynamicsEngine::init() {
	bool status{ false };

	status = Py_IsInitialized();
	if (!status) {
		std::cout << "Error: Python interpreter is not initialized" << std::endl;
		return status;
	}

	status = false;

	// Append the directory containing the Python module to sys.path so that we can import it.
	PyObject *sysPath{ PySys_GetObject((char *)"path") };

	if (!sysPath) {
		std::cout << "Error: Failed to get sys.path" << std::endl;
		PyErr_Print();
		return status;
	}

	if (!PyList_Check(sysPath)) {
		std::cout << "Error: sys.path is not a list" << std::endl;
		PyErr_Print();
		return status;
	}

	const char *dynamics_engine_scripts_dir{ SAM_DYNAMICS_ENGINE_SCRIPTS_DIR };

	if (!fs::exists(dynamics_engine_scripts_dir)) {
		std::cout << "Error: Dynamics engine scripts directory does not exist." << std::endl;
		return status;
	}

	// The dynamics_ENGINE_SCRIPTS_DIR macro is defined in the CMakeLists.txt file.
	PyList_Append(sysPath, PyUnicode_FromString(dynamics_engine_scripts_dir));

	status = true;
	return status;
}

bool DynamicsEngine::get_tokenized_api_call_sequence(const std::string &pe_file_path, std::vector<int> &tokenized_api_call_sequence_buffer) {
	bool status{ false };

	if (!fs::exists(pe_file_path)) {
		std::cout << "Error: PE report file does not exist" << std::endl;
		return status;
	}

	/*
		We assume that the sandboxed report already exists next the PE
		file and have the same name except for the extension.
	*/

	// Get only the filename without the extension
	std::string pe_file_name{ fs::path(pe_file_path).stem().string() };

	// Get the sandboxed report file path
	fs::path sandboxed_report_file_path{ fs::path(pe_file_path).parent_path() / (pe_file_name + ".json") };

	// Convert the path to a UTF-8 encoded string
	std::string sandboxed_report_file_path_string{ sandboxed_report_file_path.string() };

	if (!fs::exists(sandboxed_report_file_path)) {
		std::cout << "Error: Sandbox report file does not exist" << std::endl;
		return status;
	}

	status = Py_IsInitialized();
	if (!status) {
		std::cout << "Error: Python interpreter is not initialized" << std::endl;
		return status;
	}

	status = false;

	if (!DynamicsEngine::pModule) {
		DynamicsEngine::pModule = PyImport_ImportModule("extract_and_clean_api_calls_sequence");
		if (!DynamicsEngine::pModule || PyErr_Occurred()) {
			std::cout << "Error: Failed to import Python module" << std::endl;
			PyErr_Print();
			return status;
		}
	}

	if (!DynamicsEngine::pFunc) {
		DynamicsEngine::pFunc = PyObject_GetAttrString(pModule, "ready_to_model");
		if (!DynamicsEngine::pFunc || PyErr_Occurred()) {
			std::cout << "Error: Failed to get ready_to_model function" << std::endl;
			PyErr_Print();
			return status;
		}
	}

	if (!PyCallable_Check(DynamicsEngine::pFunc)) {
		std::cout << "Error: ready_to_model is not callable" << std::endl;
		PyErr_Print();
		return status;
	}

	// Get the tokenizer from the macro
	std::string tokenizer{ SAM_DYNAMIC_CNN_BIGRU_TOKINZER };

	// Append tokenizer.json on the path
	tokenizer += "/tokenizer.json";

	// The function ready_to_model takes 3 arguments:
	PyObject *pArgs{ PyTuple_New(3) };

	if (!pArgs) {
		std::cout << "Error: Failed to create a new tuple" << std::endl;
		PyErr_Print();
		return status;
	}

	// The first argument is the path to the sandboxed report file
	PyTuple_SetItem(pArgs, 0, PyUnicode_FromString(sandboxed_report_file_path_string.c_str()));

	// The second argument is the tokenizer
	PyTuple_SetItem(pArgs, 1, PyUnicode_FromString(tokenizer.c_str()));

	// The third argument is the size of sequence to return
	PyTuple_SetItem(pArgs, 2, PyLong_FromLong(CNN_BIGRU_API_CALL_SEQUENCE_MAXIMUM_LENGTH));

	// Call the Python function ready_to_model with the provided sandboxed report file path
	PyObject *pApiCallSequence{ PyObject_CallObject(DynamicsEngine::pFunc, pArgs) };

	if (!pApiCallSequence) {
		std::cout << "Error: Failed to get the API call sequence" << std::endl;
		PyErr_Print();
		return status;
	}

	// The returned object is a tuple of two elements (hash, api_call_sequence)
	if (!PyTuple_Check(pApiCallSequence)) {
		std::cout << "Error: The returned object is not a tuple" << std::endl;
		PyErr_Print();
		return status;
	}

	if (PyTuple_Size(pApiCallSequence) != 2) {
		std::cout << "Error: The returned tuple does not have 2 elements" << std::endl;
		PyErr_Print();
		return status;
	}

	PyObject *pHash{ PyTuple_GetItem(pApiCallSequence, 0) };

	if (!pHash) {
		std::cout << "Error: Failed to get the hash" << std::endl;
		PyErr_Print();
		return status;
	}

	status = pHash && PyUnicode_Check(pHash);

	if (!status) {
		std::cout << "Error: No hash found." << std::endl;
		PyErr_Print();
		return status;
	}

	status = false;

	PyObject *pApiCallSequenceList{ PyTuple_GetItem(pApiCallSequence, 1) };

	if (!pApiCallSequenceList) {
		std::cout << "Error: Failed to get the API call sequence list" << std::endl;
		PyErr_Print();
		return status;
	}

	if (!PyList_Check(pApiCallSequenceList)) {
		std::cout << "Error: The API call sequence list is not a list" << std::endl;
		PyErr_Print();
		return status;
	}

	Py_ssize_t listSize{ PyList_Size(pApiCallSequenceList) };

	if (listSize == 0) {
		std::cout << "Error: The API call sequence list is empty" << std::endl;
		PyErr_Print();
		return status;
	}

	tokenized_api_call_sequence_buffer.clear();

	// Convert Python list to C++ array
	for (Py_ssize_t i{ 0 }; i < listSize; i++) {
		PyObject *pItem{ PyList_GetItem(pApiCallSequenceList, i) };

		if (!pItem) {
			std::cout << "Error: A feature value found to be nullptr" << std::endl;
			PyErr_Print();
			return status;
		}

		if (!PyLong_Check(pItem)) {
			std::cout << "Error: The item at index " << i << " is not an integer" << std::endl;
			PyErr_Print();
			return status;
		}

		tokenized_api_call_sequence_buffer.emplace_back(PyLong_AsLong(pItem));
	}

	Py_DECREF(pArgs);

	Py_DECREF(pApiCallSequence);

	status = true;
	return status;
}
