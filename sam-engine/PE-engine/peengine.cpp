#include "peengine.h"

#include <iostream>

PEEngine::PEEngine() : pModule(nullptr), pFunc(nullptr) {
    // Append the directory containing the Python module to sys.path so that we can import it.
    PyObject* sysPath = PySys_GetObject((char*)"path");

    // The PE_ENGINE_SCRIPTS_DIR macro is defined in the CMakeLists.txt file.
    PyList_Append(sysPath, PyUnicode_FromString(PE_ENGINE_SCRIPTS_DIR));
}

PEEngine::~PEEngine() {
    if (!Py_IsInitialized()) return;

    if (PEEngine::pFunc) {
        // Release the reference to the function object
        Py_DECREF(PEEngine::pFunc);
    }

    if (PEEngine::pModule) {
        // Release the reference to the module object
        Py_DECREF(PEEngine::pModule);
    }
}

bool PEEngine::get_pe_features(const std::string& pe_file_path, std::vector<float>& features_buffer) {
    bool status {false};

    if (!PEEngine::pModule) {
        PEEngine::pModule = PyImport_ImportModule("get_pe_features");
        if (!PEEngine::pModule) {
            std::cout << "Error: Failed to import Python module" << std::endl;
            PyErr_Print();
            return status;
        }
    }

    if (!PEEngine::pFunc) {
        PEEngine::pFunc = PyObject_GetAttrString(pModule, "get_pe_features");
        if (!PEEngine::pFunc) {
            std::cout << "Error: Failed to get get_pe_features function" << std::endl;
            PyErr_Print();
            return status;
        }
    }

    if (!PyCallable_Check(PEEngine::pFunc)) {
        std::cout << "Error: get_pe_features is not callable" << std::endl;
        PyErr_Print();
        return status;
    }

    PyObject* pFeaturesBuffer = PyList_New(0);

    if (!pFeaturesBuffer) {
        std::cout << "Error: Failed to create a new list" << std::endl;
        PyErr_Print();
        return status;
    }

    // Get standardize_params from MACRO.
    const std::string standardize_params {STATIC_ANN_STANDARDIZE_PARAMS};

    // Call the Python function get_pe_features with the provided pe_file_path
    PyObject* pArgs = PyTuple_New(3);

    if (!pArgs) {
        std::cout << "Error: Failed to create a new tuple" << std::endl;
        PyErr_Print();
        return status;
    }

    PyTuple_SetItem(pArgs, 0, PyUnicode_FromString(pe_file_path.c_str()));
    PyTuple_SetItem(pArgs, 1, PyUnicode_FromString(standardize_params.c_str()));
    PyTuple_SetItem(pArgs, 2, pFeaturesBuffer);

    PyObject* pReturn = PyObject_CallObject(pFunc, pArgs);

    // Check the status returned by the Python function.
    status = pReturn && PyObject_IsTrue(pReturn);

    if (!status) {
        std::cout << "Error: Failed to get PE features" << std::endl;
        PyErr_Print();
        return status;
    }

    Py_ssize_t listSize = PyList_Size(pFeaturesBuffer);

    // Convert Python list to C++ array
    for (Py_ssize_t i {0}; i < listSize; i++) {
        PyObject* pItem = PyList_GetItem(pFeaturesBuffer, i);
        if (!pItem) {
            std::cout << "Error: A feature value found to be nullptr" << std::endl;
            PyErr_Print();
            return status;
        }

        if (!PyFloat_Check(pItem)) {
            std::cout << "Error: The features must be float32."
                        << " "
                        << Py_TYPE(pItem)->tp_name
                        << " "
                        << "found instead."
                        << std::endl;
            PyErr_Print();
            return status;
        }

        features_buffer.emplace_back((float)PyFloat_AsDouble(pItem));

        // Clean up
        // TODO: This line is causing a crash. Investigate.
        // See https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF.
        // Py_DECREF(pItem);
    }

    Py_DECREF(pArgs);

    Py_DECREF(pFeaturesBuffer);

    status = true;

    return status;
}
