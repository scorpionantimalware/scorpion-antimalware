#include "peengine.h"

#include <iostream>

PEEngine::PEEngine() : pModule(nullptr), pFunc(nullptr) {
    Py_Initialize();

    // Append the directory containing your Python module to sys.path
    PyObject* sysPath = PySys_GetObject((char*)"path");
    PyList_Append(sysPath, PyUnicode_FromString(PE_ENGINE_SCRIPTS_DIR));

    PEEngine::pModule = PyImport_ImportModule("get_pe_features");
    if (PEEngine::pModule == nullptr) {
        std::cerr << "Error: Failed to import Python module" << std::endl;
        PyErr_Print();
    }

    // Get a reference to the function you want to call
    PEEngine::pFunc = PyObject_GetAttrString(pModule, "get_pe_features");
    if (PEEngine::pFunc == nullptr) {
        std::cerr << "Error: Failed to get get_pe_features function" << std::endl;
        PyErr_Print();
    }
}


FeaturesArray PEEngine::get_pe_features(const std::string& file_path) {
    FeaturesArray result;

    // Initialize result with default values
    result.features = nullptr;
    result.size = 0;

    // Call the Python function get_pe_features with the provided file_path
    PyObject* pArgs = PyTuple_New(1);
    PyTuple_SetItem(pArgs, 0, PyUnicode_FromString(file_path.c_str()));

    PyObject* pReturn = PyObject_CallObject(pFunc, pArgs);

    if (pReturn != nullptr) {
        // Check if the returned object is a list
        if (PyList_Check(pReturn)) {
            Py_ssize_t listSize = PyList_Size(pReturn);
            result.size = static_cast<size_t>(listSize);

            // Allocate memory for the C++ array
            result.features = new double[result.size];

            // Convert Python list to C++ array
            for (Py_ssize_t i = 0; i < listSize; ++i) {
                PyObject* pItem = PyList_GetItem(pReturn, i);
                if (PyFloat_Check(pItem)) {
                    result.features[i] = PyFloat_AsDouble(pItem);
                } else {
                    // Handle error: unexpected type in the list
                    // Cleanup allocated memory if needed
                    delete[] result.features;
                    result.features = nullptr;
                    result.size = 0;
                    break;
                }
            }
        } else {
            // Handle error: the returned object is not a list
            PyErr_Print();
        }

        // Clean up
        Py_DECREF(pReturn);
    } else {
        // Handle error: PyObject_CallObject failed
        PyErr_Print();
    }

    Py_DECREF(pArgs);

    return result;
}

PEEngine::~PEEngine() {
    if (!Py_IsInitialized()) return;

    // Release the reference to the function object
    Py_XDECREF(PEEngine::pFunc);

    // Release the reference to the module object
    Py_DECREF(PEEngine::pModule);

    // This is a no-op when called for a second time (without calling Py_Initialize() again first). 
    // Normally the return value is 0. If there were errors during finalization (flushing buffered data), -1 is returned.
    if (Py_FinalizeEx() < 0) {
        std::cerr << "Error: Failed to finalize Python interpreter" << std::endl;
        PyErr_Print();
    }
}

