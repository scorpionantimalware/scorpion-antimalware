#include "peengine.h"

#include <iostream>

PEEngine::PEEngine() : pModule(nullptr), pFunc(nullptr) {
    // Append the directory containing the Python module to sys.path so that we can import it.
    PyObject* sysPath = PySys_GetObject((char*)"path");

    // The PE_ENGINE_SCRIPTS_DIR macro is defined in the CMakeLists.txt file.
    PyList_Append(sysPath, PyUnicode_FromString(PE_ENGINE_SCRIPTS_DIR));

    PEEngine::pModule = PyImport_ImportModule("get_pe_features");
    if (PEEngine::pModule == nullptr) {
        std::cerr << "Error: Failed to import Python module" << std::endl;
        PyErr_Print();
    }

    // Get a reference to the function you want to call
    PEEngine::pFunc = PyObject_GetAttrString(pModule, "get_pe_features");
    if (PEEngine::pFunc == nullptr) {
        std::cerr << "Error: Failed to get get_pe_features function" << std::endl;
        PyErr_Print();
    }
}


bool PEEngine::get_pe_features(const std::string& pe_file_path, std::vector<float>& features_buffer) {
    bool status {false};

    if (!PyCallable_Check(PEEngine::pFunc)) {
        std::cout << "Error: get_pe_features is not callable" << std::endl;
        return status;
    }

    PyObject* pFeaturesBuffer = PyList_New(0);

    // Get standardize_params from MACRO.
    const std::string standardize_params {STATIC_ANN_STANDARDIZE_PARAMS};

    // Call the Python function get_pe_features with the provided pe_file_path
    PyObject* pArgs = PyTuple_New(3);
    PyTuple_SetItem(pArgs, 0, PyUnicode_FromString(pe_file_path.c_str()));
    PyTuple_SetItem(pArgs, 1, PyUnicode_FromString(standardize_params.c_str()));
    PyTuple_SetItem(pArgs, 2, pFeaturesBuffer);

    PyObject* pReturn = PyObject_CallObject(pFunc, pArgs);

    // Check the status returned by the Python function.
    status = pReturn && PyObject_IsTrue(pReturn);

    if (!status) {
        std::cout << "Error: Failed to get PE features" << std::endl;
        return status;
    }

    Py_ssize_t listSize = PyList_Size(pFeaturesBuffer);

    // Convert Python list to C++ array
    for (Py_ssize_t i {0}; i < listSize; i++) {
        PyObject* pItem = PyList_GetItem(pFeaturesBuffer, i);
        if (!pItem) {
            std::cout << "Error: A feature value found to be nullptr" << std::endl;
            return status;
        }

        if (!PyFloat_Check(pItem)) {
            std::cout << "Error: The features must be float32" << std::endl;
            return status;
        }

        features_buffer.emplace_back((float)PyFloat_AsDouble(pItem));

        // Clean up
        Py_DECREF(pItem);
    }

    if (pArgs != nullptr) {
        // Clean up
        Py_DECREF(pArgs);
    }

    if (pFeaturesBuffer != nullptr) {
        // Clean up
        Py_DECREF(pFeaturesBuffer);
    }

    status = true;

    return status;
}

PEEngine::~PEEngine() {
    if (!Py_IsInitialized()) return;

    if (PEEngine::pFunc != nullptr) {
        // Release the reference to the function object
        Py_DECREF(PEEngine::pFunc);
    }

    if (PEEngine::pModule != nullptr) {
        // Release the reference to the module object
        Py_DECREF(PEEngine::pModule);
    }
}

