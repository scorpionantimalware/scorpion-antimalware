#include "peengine.h"

#include <iostream>

PEEngine::PEEngine() : pModule(nullptr), pFunc(nullptr) {
    Py_Initialize();

    // Append the directory containing your Python module to sys.path
    PyObject* sysPath = PySys_GetObject((char*)"path");
    PyList_Append(sysPath, PyUnicode_FromString(PE_ENGINE_SCRIPTS_DIR));

    PEEngine::pModule = PyImport_ImportModule("get_pe_features");
    if (PEEngine::pModule == nullptr) {
        std::cout << "Error: Failed to import Python module" << std::endl;
        PyErr_Print();
    }

    // Get a reference to the function you want to call
    PEEngine::pFunc = PyObject_GetAttrString(pModule, "get_pe_features");
}


FeaturesArray PEEngine::get_pe_features(std::string& file_path) {
    if (PEEngine::pModule == nullptr) {
        std::cout << "Error: Failed to import Python module" << std::endl;
    }

    if (PEEngine::pFunc == nullptr) {
        std::cout << "Error: Failed to get function from Python module" << std::endl;
    }

    FeaturesArray result;

    return result;
}

PEEngine::~PEEngine() {
    if (!Py_IsInitialized()) return;

    // Release the reference to the function object
    Py_XDECREF(PEEngine::pFunc);

    // Release the reference to the module object
    Py_DECREF(PEEngine::pModule);

    // This is a no-op when called for a second time (without calling Py_Initialize() again first). 
    // Normally the return value is 0. If there were errors during finalization (flushing buffered data), -1 is returned.
    if (Py_FinalizeEx() < 0) {
        std::cout << "Error: Failed to finalize Python interpreter" << std::endl;
    }
}

