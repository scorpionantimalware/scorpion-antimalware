/**********************************************************************************/
/*                                                                                */
/* peengine.cpp                                                                   */
/*                                                                                */
/**********************************************************************************/
/*                                                                                */
/*    Scorpion Anti-malware is a free Open Source AI-powered Anti-malware         */
/*    framework for Researchers.                                                  */
/*                                                                                */
/*    Copyright (c) 2024-present  (see AUTHORS.md).                               */
/*                                                                                */
/*    This program is free software: you can redistribute it and/or modify        */
/*    it under the terms of the GNU General Public License as published by        */
/*    the Free Software Foundation, either version 3 of the License, or           */
/*    (at your option) any later version.                                         */
/*                                                                                */
/*    This program is distributed in the hope that it will be useful,             */
/*    but WITHOUT ANY WARRANTY; without even the implied warranty of              */
/*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               */
/*    GNU General Public License for more details.                                */
/*                                                                                */
/*    You should have received a copy of the GNU General Public License           */
/*    along with this program.  If not, see <https://www.gnu.org/licenses/>.      */
/*                                                                                */
/**********************************************************************************/

#include "peengine.hpp"

#include <filesystem>

namespace fs = std::filesystem;

#include <iostream>

PEEngine::PEEngine() : pModule(nullptr), pFunc(nullptr) {
    
}

PEEngine::~PEEngine() {
    if (PEEngine::pFunc) {
        // Release the reference to the function object
        Py_DECREF(PEEngine::pFunc);
    }

    if (PEEngine::pModule) {
        // Release the reference to the module object
        Py_DECREF(PEEngine::pModule);
    }
}

bool PEEngine::init() {
    bool status {false};

    status = Py_IsInitialized();
    if (!status) {
        std::cout << "Error: Python interpreter is not initialized" << std::endl;
        return status;
    }

    status = false;

    // Append the directory containing the Python module to sys.path so that we can import it.
    PyObject* sysPath {PySys_GetObject((char*)"path")};

    if (!sysPath) {
        std::cout << "Error: Failed to get sys.path" << std::endl;
        PyErr_Print();
        return status;
    }

    if (!PyList_Check(sysPath)) {
        std::cout << "Error: sys.path is not a list" << std::endl;
        PyErr_Print();
        return status;
    }

    const char* pe_engine_scripts_dir {SAM_PE_ENGINE_SCRIPTS_DIR};

    if (!fs::exists(pe_engine_scripts_dir)) {
        std::cout << "Error: PE engine scripts directory does not exist." << std::endl;
        return status;
    }

    // The PE_ENGINE_SCRIPTS_DIR macro is defined in the CMakeLists.txt file.
    PyList_Append(sysPath, PyUnicode_FromString(pe_engine_scripts_dir));

    status = true;

    return status;
}

bool PEEngine::get_pe_features(const std::string& pe_file_path, std::vector<float>& features_buffer) {
    bool status {false};

    status = Py_IsInitialized();
    if (!status) {
        std::cout << "Error: Python interpreter is not initialized" << std::endl;
        return status;
    }

    status = false;

    if (!PEEngine::pModule) {
        PEEngine::pModule = PyImport_ImportModule("get_pe_features");
        if (!PEEngine::pModule || PyErr_Occurred()) {
            std::cout << "Error: Failed to import Python module" << std::endl;
            PyErr_Print();
            return status;
        }
    }

    if (!PEEngine::pFunc) {
        PEEngine::pFunc = PyObject_GetAttrString(pModule, "get_pe_features");
        if (!PEEngine::pFunc || PyErr_Occurred()) {
            std::cout << "Error: Failed to get get_pe_features function" << std::endl;
            PyErr_Print();
            return status;
        }
    }

    if (!PyCallable_Check(PEEngine::pFunc)) {
        std::cout << "Error: get_pe_features is not callable" << std::endl;
        PyErr_Print();
        return status;
    }

    PyObject* pFeaturesBuffer {PyList_New(0)};

    if (!pFeaturesBuffer) {
        std::cout << "Error: Failed to create a new list" << std::endl;
        PyErr_Print();
        return status;
    }

    // Get standardize_params from MACRO.
    const std::string standardize_params {SAM_STATIC_ANN_STANDARDIZE_PARAMS};

    // Call the Python function get_pe_features with the provided pe_file_path
    PyObject* pArgs {PyTuple_New(3)};

    if (!pArgs) {
        std::cout << "Error: Failed to create a new tuple" << std::endl;
        PyErr_Print();
        return status;
    }

    PyTuple_SetItem(pArgs, 0, PyUnicode_FromString(pe_file_path.c_str()));
    PyTuple_SetItem(pArgs, 1, PyUnicode_FromString(standardize_params.c_str()));
    PyTuple_SetItem(pArgs, 2, pFeaturesBuffer);

    PyObject* pReturn {PyObject_CallObject(PEEngine::pFunc, pArgs)};

    // Check the status returned by the Python function.
    status = pReturn && PyObject_IsTrue(pReturn);

    if (!status) {
        std::cout << "Error: Failed to get PE features" << std::endl;
        PyErr_Print();
        return status;
    }

    status = false;

    Py_ssize_t listSize {PyList_Size(pFeaturesBuffer)};

    // Convert Python list to C++ array
    for (Py_ssize_t i {0}; i < listSize; i++) {
        PyObject* pItem {PyList_GetItem(pFeaturesBuffer, i)};
        if (!pItem) {
            std::cout << "Error: A feature value found to be nullptr" << std::endl;
            PyErr_Print();
            return status;
        }

        if (!PyFloat_Check(pItem)) {
            std::cout << "Error: The features must be float32."
                        << " "
                        << Py_TYPE(pItem)->tp_name
                        << " "
                        << "found instead."
                        << std::endl;
            PyErr_Print();
            return status;
        }

        features_buffer.emplace_back(static_cast<float>(PyFloat_AsDouble(pItem)));

        // Clean up
        // TODO: This line is causing a crash. Investigate.
        // See https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF.
        // Py_DECREF(pItem);
    }

    Py_DECREF(pArgs);

    Py_DECREF(pFeaturesBuffer);

    status = true;

    return status;
}
