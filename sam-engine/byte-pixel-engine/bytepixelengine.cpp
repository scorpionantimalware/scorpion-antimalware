/**
 *                        بِسْمِ اللَّهِ الرَّحْمَنِ الرَّحِيمِ
 * 
 * bytepixelengine.cpp
 * 
 * Copyright (c) 2024-present Scorpion Anti-malware (see AUTHORS.md).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 */

#include "bytepixelengine.hpp"

#include <filesystem>

namespace fs = std::filesystem;

#include <iostream>

BytePixelEngine::BytePixelEngine() : pModule(nullptr), pFunc(nullptr) {}

BytePixelEngine::~BytePixelEngine() {    
    if (BytePixelEngine::pFunc) {
        Py_DECREF(BytePixelEngine::pFunc);
    }

    if (BytePixelEngine::pModule) {
        Py_DECREF(BytePixelEngine::pModule);
    }
}

bool BytePixelEngine::init() {
    bool status {false};

    status = Py_IsInitialized();
    if (!status) {
        std::cout << "Error: Python interpreter is not initialized" << std::endl;
        return status;
    }

    // Append the directory containing the Python module to sys.path so that we can import it.
    PyObject* sysPath {PySys_GetObject((char*)"path")};

    if (!sysPath) {
        std::cout << "Error: Failed to get sys.path" << std::endl;
        PyErr_Print();
        return status;
    }

    if (!PyList_Check(sysPath)) {
        std::cout << "Error: sys.path is not a list" << std::endl;
        PyErr_Print();
        return status;
    }

    const char* byte_pixel_engine_scripts_dir {SAM_BYTE_PIXEL_ENGINE_SCRIPTS_DIR};

    if (!fs::exists(byte_pixel_engine_scripts_dir)) {
        std::cout << "Error: Byte pixel engine scripts directory does not exist." << std::endl;
        return status;
    }

    // The PE_ENGINE_SCRIPTS_DIR macro is defined in the CMakeLists.txt file.
    PyList_Append(sysPath, PyUnicode_FromString(byte_pixel_engine_scripts_dir));

    status = true;

    return status;
}

bool BytePixelEngine::get_byte_pixel_features(const std::string& pe_file_path, std::vector<float>& features_buffer) {
    bool status {false};

    status = Py_IsInitialized();
    if (!status) {
        std::cout << "Error: Python interpreter is not initialized" << std::endl;
        return status;
    }

    if (!BytePixelEngine::pModule) {
        BytePixelEngine::pModule = PyImport_ImportModule("exe_to_img");
        if (!BytePixelEngine::pModule) {
            std::cout << "Error: Failed to import Python module" << std::endl;
            PyErr_Print();
            return status;
        }
    }

    if (!BytePixelEngine::pFunc) {
        BytePixelEngine::pFunc = PyObject_GetAttrString(pModule, "from_exe_to_np_img");
        if (!BytePixelEngine::pFunc) {
            std::cout << "Error: Failed to get get_pe_features function" << std::endl;
            PyErr_Print();
            return status;
        }
    }

    if (!PyCallable_Check(BytePixelEngine::pFunc)) {
        std::cout << "Error: get_pe_features is not callable" << std::endl;
        PyErr_Print();
        return status;
    }

    PyObject* pFeaturesBuffer {PyList_New(0)};

    if (!pFeaturesBuffer) {
        std::cout << "Error: Failed to create a new list" << std::endl;
        PyErr_Print();
        return status;
    }

    // Get colormap from MACRO.
    const std::string colormap {SAM_STATIC_CNN_COLORMAP};

    // Call the Python function from_exe_to_np_img with the provided pe_file_path
    PyObject* pArgs {PyTuple_New(3)};

    if (!pArgs) {
        std::cout << "Error: Failed to create a new tuple" << std::endl;
        PyErr_Print();
        return status;
    }

    PyTuple_SetItem(pArgs, 0, PyUnicode_FromString(pe_file_path.c_str()));
    PyTuple_SetItem(pArgs, 1, PyUnicode_FromString(colormap.c_str()));
    PyTuple_SetItem(pArgs, 2, pFeaturesBuffer);

    PyObject* pReturn {PyObject_CallObject(pFunc, pArgs)};

    // Check the status returned by the Python function.
    status = pReturn && PyObject_IsTrue(pReturn);

    if (!status) {
        std::cout << "Error: Failed to get image features" << std::endl;
        PyErr_Print();
        return status;
    }

    Py_ssize_t listSize {PyList_Size(pFeaturesBuffer)};

    // Convert Python list to C++ array
    for (Py_ssize_t i {0}; i < listSize; i++) {
        PyObject* pItem {PyList_GetItem(pFeaturesBuffer, i)};
        if (!pItem) {
            std::cout << "Error: A feature value found to be nullptr" << std::endl;
            PyErr_Print();
            return status;
        }

        if (!PyFloat_Check(pItem)) {
            std::cout << "Error: The features must be float32."
                        << " "
                        << Py_TYPE(pItem)->tp_name
                        << " "
                        << "found instead."
                        << std::endl;
            PyErr_Print();
            return status;
        }

        features_buffer.emplace_back(static_cast<float>(PyFloat_AsDouble(pItem)));

        // Clean up
        // TODO: This line is causing a crash. Investigate.
        // See https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF.
        // Py_DECREF(pItem);
    }

    // for (Py_ssize_t i {0}; i < listSize; i++) {
    //     PyObject* pItem {PyList_GetItem(pFeaturesBuffer, i)};
    //     if (!pItem) {
    //         std::cout << "Error: A feature value found to be nullptr" << std::endl;
    //         PyErr_Print();
    //         return status;
    //     }

    //     if (!PyList_Check(pItem)) {
    //         std::cout << "Error: The features must be a list of lists of floats."
    //                     << " "
    //                     << Py_TYPE(pItem)->tp_name
    //                     << " "
    //                     << "found instead."
    //                     << std::endl;
    //         PyErr_Print();
    //         return status;
    //     }

    //     Py_ssize_t innerListSize {PyList_Size(pItem)};
    //     std::vector<std::vector<float>> innerList;
    //     for (Py_ssize_t j {0}; j < innerListSize; j++) {
    //         PyObject* pInnerItem {PyList_GetItem(pItem, j)};
    //         if (!pInnerItem) {
    //             std::cout << "Error: A feature value found to be nullptr" << std::endl;
    //             PyErr_Print();
    //             return status;
    //         }

    //         if (!PyList_Check(pInnerItem)) {
    //             std::cout << "Error: The features must be a list of lists of floats."
    //                         << " "
    //                         << Py_TYPE(pInnerItem)->tp_name
    //                         << " "
    //                         << "found instead."
    //                         << std::endl;
    //             PyErr_Print();
    //             return status;
    //         }

    //         Py_ssize_t innerInnerListSize {PyList_Size(pInnerItem)};
    //         std::vector<float> innerInnerList;
    //         for (Py_ssize_t k {0}; k < innerInnerListSize; k++) {
    //             PyObject* pInnerInnerItem {PyList_GetItem(pInnerItem, k)};
                
    //             if (!pInnerInnerItem) {
    //                 std::cout << "Error: A feature value found to be nullptr" << std::endl;
    //                 PyErr_Print();
    //                 return status;
    //             }

    //             if (!PyFloat_Check(pInnerInnerItem)) {
    //                 std::cout << "Error: The features must be float32."
    //                             << " "
    //                             << Py_TYPE(pInnerInnerItem)->tp_name
    //                             << " "
    //                             << "found instead."
    //                             << std::endl;
    //                 PyErr_Print();
    //                 return status;
    //             }

    //             innerInnerList.emplace_back((float)PyFloat_AsDouble(pInnerInnerItem));

    //             // Clean up
    //             // TODO: This line is causing a crash. Investigate.
    //             // See https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF.
    //             // Py_DECREF(pInnerInnerItem);
    //         }
    //         innerList.emplace_back(innerInnerList);
    //         // Clean up
    //         Py_DECREF(pInnerItem);
    //     }
    //     features_buffer.emplace_back(innerList);
    //     // Clean up
    //     Py_DECREF(pItem);
    // }

    Py_DECREF(pArgs);

    Py_DECREF(pFeaturesBuffer);

    status = true;

    return status;
}
