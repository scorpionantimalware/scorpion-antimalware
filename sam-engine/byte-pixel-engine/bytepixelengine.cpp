#include "bytepixelengine.h"
#include <iostream>


BytePixelEngine::BytePixelEngine() : pModule(nullptr), pFunc(nullptr) {
    // Append the directory containing your Python module to sys.path
    PyObject* sysPath = PySys_GetObject((char*)"path");
    PyList_Append(sysPath, PyUnicode_FromString(BYTE_PIXEL_ENGINE_SCRIPTS_DIR));
    BytePixelEngine::pModule = PyImport_ImportModule("exe_to_img");
    if (BytePixelEngine::pModule == nullptr) {
        std::cerr << "Error: Failed to import Python module" << std::endl;
        PyErr_Print();
    }
    // Get a reference to the function you want to call
    BytePixelEngine::pFunc = PyObject_GetAttrString(pModule, "from_exe_to_np_img");
    if (BytePixelEngine::pFunc == nullptr) {
        std::cerr << "Error: Failed to get from_exe_to_np_img function" << std::endl;
        PyErr_Print();
    }
}

bool BytePixelEngine::get_byte_pixel_features(const std::string& pe_file_path,  std::vector<float>& features_buffer) {
    bool status {false};

    if (!PyCallable_Check(BytePixelEngine::pFunc)) {
        std::cout << "Error: get_pe_features is not callable" << std::endl;
        return status;
    }

    PyObject* pFeaturesBuffer = PyList_New(0);

    // Get standardize_params from MACRO.
    const std::string colormap {STATIC_CNN_COLORMAP};

    // Call the Python function from_exe_to_np_img with the provided pe_file_path
    PyObject* pArgs = PyTuple_New(3);
    PyTuple_SetItem(pArgs, 0, PyUnicode_FromString(pe_file_path.c_str()));
    PyTuple_SetItem(pArgs, 1, PyUnicode_FromString(colormap.c_str()));
    PyTuple_SetItem(pArgs, 2, pFeaturesBuffer);

    PyObject* pReturn = PyObject_CallObject(pFunc, pArgs);

    // Check the status returned by the Python function.
    status = pReturn && PyObject_IsTrue(pReturn);

    if (!status) {
        std::cout << "Error: Failed to get image features" << std::endl;
        return status;
    }

    Py_ssize_t listSize = PyList_Size(pFeaturesBuffer);

    // Convert Python list to C++ array
    for (Py_ssize_t i {0}; i < listSize; i++) {
        PyObject* pItem = PyList_GetItem(pFeaturesBuffer, i);
        if (!pItem) {
            std::cout << "Error: A feature value found to be nullptr" << std::endl;
            return status;
        }

        if (!PyFloat_Check(pItem)) {
            std::cout << "Error: The features must be float32" << std::endl;
            return status;
        }

        features_buffer.emplace_back((float)PyFloat_AsDouble(pItem));

        // Clean up
        Py_DECREF(pItem);
    }

    if (pArgs != nullptr) {
        // Clean up
        Py_DECREF(pArgs);
    }

    if (pFeaturesBuffer != nullptr) {
        // Clean up
        Py_DECREF(pFeaturesBuffer);
    }

    status = true;

    return status;
}

BytePixelEngine::~BytePixelEngine() {
     if (!Py_IsInitialized()) return;
    if (BytePixelEngine::pFunc != nullptr) {
        Py_DECREF(BytePixelEngine::pFunc);
    }
    if (BytePixelEngine::pModule != nullptr) {
        Py_DECREF(BytePixelEngine::pModule);
    }
}
