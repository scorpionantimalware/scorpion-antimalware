###################################################################################
#                                                                                 #
# exe_to_img.py                                                                   #
#                                                                                 #
###################################################################################
#                                                                                 #
#    Scorpion Anti-malware is a free Open Source AI-powered Anti-malware          #
#    framework for Researchers.                                                   #
#                                                                                 #
#    Copyright (c) 2024-present  (see AUTHORS.md).                                #
#                                                                                 #
#    This program is free software: you can redistribute it and/or modify         #
#    it under the terms of the GNU General Public License as published by         #
#    the Free Software Foundation, either version 3 of the License, or            #
#    (at your option) any later version.                                          #
#                                                                                 #
#    This program is distributed in the hope that it will be useful,              #
#    but WITHOUT ANY WARRANTY; without even the implied warranty of               #
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
#    GNU General Public License for more details.                                 #
#                                                                                 #
#    You should have received a copy of the GNU General Public License            #
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.       #
#                                                                                 #
###################################################################################


import numpy as np
from PIL import Image
from itertools import zip_longest
import numpy as np
from random import randint 
import math
from typing import Union, List
import os


## Helper Functions
def imgPutdata(data, size, img_type):
	try:
		image = Image.new(img_type, size)
		image.putdata(data)
	except Exception as err:
		print(err)
		return 0
	return image


def to1DArray_grayscale(img_bin_data, colormap):
	pixel_array = []
	for x, y in grouper(img_bin_data, 2) :
		new_pixel = colormap[x][y]
		pixel_array.append(new_pixel)
	return pixel_array


def readBytes_wPadding(filename, width):
	img_bin_data = []
	with open(filename, 'rb') as file:
		while True:
			b = file.read(1)
			if not b:
				break
			img_bin_data.append(int.from_bytes(b, byteorder='big'))
		while len(img_bin_data)%width!=0:
			img_bin_data.append(randint(0, 255))
	return img_bin_data


def grouper(iterable, n, fillvalue=None):
	args = [iter(iterable)] * n
	return zip_longest(fillvalue = fillvalue, *args)


def bilinear_resize_normalized(image, new_size):
    """
    Resize the input normalized image represented as a NumPy array using bilinear interpolation.

    Note that we use this function instead of PIL's resize() method as it produces the same results as 
    TensorFlow's compat.v1.image.resize().

    Args:
    - image: NumPy array representing the normalized image (2D or 3D array)
    - new_size: tuple (new_height, new_width) of the desired output size

    Returns:
    - resized_image: NumPy array of the resized normalized image
    """
    old_height, old_width = image.shape[:2]
    new_height, new_width = new_size

    # Calculate scale factors
    sx = old_width / new_width
    sy = old_height / new_height

    # Create output image
    resized_image = np.zeros((new_height, new_width) + image.shape[2:], dtype=image.dtype)

    for y in range(new_height):
        for x in range(new_width):
            # Calculate coordinates in the original image
            x_original = x * sx
            y_original = y * sy

            # Get the four surrounding pixels in the original image
            x0, y0 = int(x_original), int(y_original)
            x1, y1 = min(x0 + 1, old_width - 1), min(y0 + 1, old_height - 1)

            # Calculate the weights for bilinear interpolation
            dx = x_original - x0
            dy = y_original - y0

            # Perform bilinear interpolation
            top = image[y0, x0] * (1 - dx) + image[y0, x1] * dx
            bottom = image[y1, x0] * (1 - dx) + image[y1, x1] * dx
            resized_image[y, x] = top * (1 - dy) + bottom * dy

    return resized_image


## Main Function
def from_exe_to_np_img(full_file_path: Union[str, bytes, os.PathLike], colormap_path: Union[str, bytes, os.PathLike], features_buffer: List[float])->bool:
	"""
    Converts binary data from a PE file to a NumPy array suitable for model prediction.

    This function loads image data from an executable file, applies a colormap for conversion to grayscale, 
    and prepares the image for model prediction. The image is resized to 256x256 pixels, normalized, 
    and reshaped to fit the required input format for the model (NHWC, with an additional batch axis).
    
	Parameters:
        full_file_path (Union[str, bytes, os.PathLike]): The path to the image file. 
        	This can be provided as a string, bytes, or an object compatible with os.PathLike.
        colormap_path (Union[str, bytes, os.PathLike]): The path to the colormap file.
            This can be provided as a string, bytes, or an object compatible with os.PathLike.
		features_buffer (List[float]): The buffer to store the image data.
            
    Returns:
		bool: True if the image data was successfully loaded and prepared for model prediction, False otherwise.
    """
	inWidth = 512
	inHeight = 0
	outWidth = 256
	outHeight = 256

    # Load the colormap
	colormap = np.load(colormap_path)

    # Read image data from the executable file with padding
	img_bin_array = readBytes_wPadding(full_file_path, inWidth)

    # Convert binary image data to grayscale using the provided colormap
	grayscale_array = to1DArray_grayscale(img_bin_array, colormap)

	# Calculate the height of the grayscale image
	inHeight = math.ceil(len(grayscale_array) / inWidth)

	# Put grayscale data into an image frame
	pil_img = imgPutdata(grayscale_array, (inWidth, inHeight), 'L')
	
    # resize to outWidth X outHeight pixels
	np_img = np.array(pil_img, dtype=np.float32)
	np_resized = bilinear_resize_normalized(np_img, (outWidth, outHeight))
	
 	# Normalize the image data to the range [0, 1]
	np_resized /= 255
 
	#N-HWC >> N-CHW
	image = np.expand_dims(np_resized, axis=0)
	
	# Reshape to 1D
	img_ready_to_model = image.reshape(1,-1).squeeze().tolist()

	for i in range(len(img_ready_to_model)):
		features_buffer.append(img_ready_to_model[i])

	return True
