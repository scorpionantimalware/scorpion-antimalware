import numpy as np
from PIL import Image
from itertools import zip_longest
import numpy as np
from random import randint 
import math
from typing import Union, List
import os

## Helper Functions
def imgPutdata(data, size, img_type):
	# TODO: Remove try-except block and handle exceptions in the calling function.
	try:
		image = Image.new(img_type, size)
		image.putdata(data)
	except Exception as err:
		print(err)
		return 0
	return image

def to1DArray_grayscale(img_bin_data, colormap):
	pixel_array = []
	for x, y in grouper(img_bin_data, 2) :
		new_pixel = colormap[x][y]
		pixel_array.append(new_pixel)
	return pixel_array

def readBytes_wPadding(filename, width):
	img_bin_data = []
	with open(filename, 'rb') as file:
		while True:
			b = file.read(1)
			if not b:
				break
			img_bin_data.append(int.from_bytes(b, byteorder='big'))
		while len(img_bin_data)%width!=0:
			img_bin_data.append(randint(0, 255))
	return img_bin_data

def grouper(iterable, n, fillvalue=None):
	args = [iter(iterable)] * n
	return zip_longest(fillvalue = fillvalue, *args)


## Main Function
def from_exe_to_np_img(full_file_path: Union[str, bytes, os.PathLike], colormap_path: Union[str, bytes, os.PathLike], features_buffer: List[float])->bool:
	"""
    Converts binary data from an PEexecutable file to a NumPy array suitable for model prediction.

    This function loads image data from an executable file, applies a colormap for conversion to grayscale, 
    and prepares the image for model prediction. The image is resized to 256x256 pixels, normalized, 
    and reshaped to fit the required input format for the model (NHWC, with an additional batch axis).
    
	Parameters:
        full_file_path (Union[str, bytes, os.PathLike]): The path to the image file. 
        	This can be provided as a string, bytes, or an object compatible with os.PathLike.
        colormap_path (Union[str, bytes, os.PathLike]): The path to the colormap file.
            This can be provided as a string, bytes, or an object compatible with os.PathLike.
		features_buffer (List[float]): The buffer to store the image data.
            
    Returns:
		bool: True if the image data was successfully loaded and prepared for model prediction, False otherwise.
    """

    # Load the colormap
	colormap = np.load(colormap_path)

    # Read image data from the executable file with padding
	img_bin_array = readBytes_wPadding(full_file_path, 512)

    # Convert binary image data to grayscale using the provided colormap
	grayscale_array = to1DArray_grayscale(img_bin_array, colormap)

	# Calculate the height of the grayscale image
	height = math.ceil(len(grayscale_array) / 512)

	# Put grayscale data into an image frame, then resize to 256x256 pixels
	pil_img = imgPutdata(grayscale_array, (512, height), 'L').resize((256, 256), Image.Resampling.BILINEAR)

	# Normalize the image data to the range [0, 1]
	np_img_norm = np.array(pil_img, dtype=np.float32) / 255

	# Expand dimensions to conform to 'NHWC' format with a batch axis
	img_ready_to_model = np.expand_dims(np_img_norm, axis=0)
 
	# Reshape to 1D
	img_ready_to_model = img_ready_to_model.reshape(1,-1).squeeze()
 
	img_ready_to_model = img_ready_to_model.tolist()

	for i in range(len(img_ready_to_model)):
		features_buffer.append(img_ready_to_model[i])

	return True
