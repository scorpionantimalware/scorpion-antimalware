import numpy as np
from PIL import Image
from itertools import zip_longest
import numpy as np
from random import randint 
import math
from typing import Union, List
import os


## Helper Functions
def imgPutdata(data, size, img_type):
	try:
		image = Image.new(img_type, size)
		image.putdata(data)
	except Exception as err:
		print(err)
		return 0
	return image


def to1DArray_grayscale(img_bin_data, colormap):
	pixel_array = []
	for x, y in grouper(img_bin_data, 2) :
		new_pixel = colormap[x][y]
		pixel_array.append(new_pixel)
	return pixel_array


def readBytes_wPadding(filename, width):
	img_bin_data = []
	with open(filename, 'rb') as file:
		while True:
			b = file.read(1)
			if not b:
				break
			img_bin_data.append(int.from_bytes(b, byteorder='big'))
		while len(img_bin_data)%width!=0:
			img_bin_data.append(randint(0, 255))
	return img_bin_data


def grouper(iterable, n, fillvalue=None):
	args = [iter(iterable)] * n
	return zip_longest(fillvalue = fillvalue, *args)


def bilinear_resize_normalized(image, new_size):
    """
    Resize the input normalized image represented as a NumPy array using bilinear interpolation.

    Args:
    - image: NumPy array representing the normalized image (2D or 3D array)
    - new_size: tuple (new_height, new_width) of the desired output size

    Returns:
    - resized_image: NumPy array of the resized normalized image
    """
    old_height, old_width = image.shape[:2]
    new_height, new_width = new_size

    # Calculate scale factors
    sx = old_width / new_width
    sy = old_height / new_height

    # Create output image
    resized_image = np.zeros((new_height, new_width) + image.shape[2:], dtype=image.dtype)

    for y in range(new_height):
        for x in range(new_width):
            # Calculate coordinates in the original image
            x_original = x * sx
            y_original = y * sy

            # Get the four surrounding pixels in the original image
            x0, y0 = int(x_original), int(y_original)
            x1, y1 = min(x0 + 1, old_width - 1), min(y0 + 1, old_height - 1)

            # Calculate the weights for bilinear interpolation
            dx = x_original - x0
            dy = y_original - y0

            # Perform bilinear interpolation
            top = image[y0, x0] * (1 - dx) + image[y0, x1] * dx
            bottom = image[y1, x0] * (1 - dx) + image[y1, x1] * dx
            resized_image[y, x] = top * (1 - dy) + bottom * dy

    return resized_image


## Main Function
def from_exe_to_np_img(full_file_path: Union[str, bytes, os.PathLike], colormap_path: Union[str, bytes, os.PathLike], features_buffer: List[float])->bool:
	"""
    Converts binary data from a PE file to a NumPy array suitable for model prediction.

    Note that we use this function instead of PIL's resize() method as it produces the same results as 
    TensorFlow's compat.v1.image.resize().

    This function loads image data from an executable file, applies a colormap for conversion to grayscale, 
    and prepares the image for model prediction. The image is resized to 256x256 pixels, normalized, 
    and reshaped to fit the required input format for the model (NHWC, with an additional batch axis).
    
	Parameters:
        full_file_path (Union[str, bytes, os.PathLike]): The path to the image file. 
        	This can be provided as a string, bytes, or an object compatible with os.PathLike.
        colormap_path (Union[str, bytes, os.PathLike]): The path to the colormap file.
            This can be provided as a string, bytes, or an object compatible with os.PathLike.
		features_buffer (List[float]): The buffer to store the image data.
            
    Returns:
		bool: True if the image data was successfully loaded and prepared for model prediction, False otherwise.
    """
	inWidth = 512
	inHeight = 0
	outWidth = 256
	outHeight = 256

    # Load the colormap
	colormap = np.load(colormap_path)

    # Read image data from the executable file with padding
	img_bin_array = readBytes_wPadding(full_file_path, inWidth)

    # Convert binary image data to grayscale using the provided colormap
	grayscale_array = to1DArray_grayscale(img_bin_array, colormap)

	# Calculate the height of the grayscale image
	inHeight = math.ceil(len(grayscale_array) / inWidth)

	# Put grayscale data into an image frame
	pil_img = imgPutdata(grayscale_array, (inWidth, inHeight), 'L')
	
    # resize to outWidth X outHeight pixels
	np_img = np.array(pil_img, dtype=np.float32)
	np_resized = bilinear_resize_normalized(np_img, (outWidth, outHeight))
	
 	# Normalize the image data to the range [0, 1]
	np_resized /= 255
 
	#N-HWC >> N-CHW
	image = np.expand_dims(np_resized, axis=0)
	
	# Reshape to 1D
	img_ready_to_model = image.reshape(1,-1).squeeze().tolist()

	for i in range(len(img_ready_to_model)):
		features_buffer.append(img_ready_to_model[i])

	return True
