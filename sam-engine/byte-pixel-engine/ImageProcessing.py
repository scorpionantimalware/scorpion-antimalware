# ref: https://github.com/ncarkaci/binary-to-image
import numpy as np
from PIL import Image
from numpy import save
from itertools import zip_longest
import numpy as np
import tensorflow as tf
from random import randint 

def defineColorMap():
  rows  = 256
  columns = 256
  min = 0 
  max = 256
  step = 2
  colormap = np.random.randint(min, max, size=rows * columns, dtype='l')
  colormap.resize(rows,columns)
  print(colormap)
  print("\n\n ",colormap.shape)
  save('/content/drive/MyDrive/DataSets/simulation_folder/dataset/colormap/gray_colormap.npy', colormap)  
  return colormap

# defineColorMap()
# upon initializing the blackbox system it is necessary to create the colormap used to convert the images by using the following instruction 
# gray_colormap = defineColorMap()

# This function is used to read binary data from a file as bytes. These bytes will be available as decimal values to use as pixel values.
def readBytes (filename):
  img_bin_data = []
  with open(filename, 'rb') as file:
    while True:
      b = file.read(1)
      if not b:
        break
      img_bin_data.append(int.from_bytes(b, byteorder='big'))
  return img_bin_data

# This function is used to read values from a previously stored numpy array.
def readBytes_fromNumpy (filename):
  return np.load(filename)

# This function is used to read binary data from a file as bytes and add padding values if the file size is not in a specific range. 
# The bytes will be available as decimal values to use as pixel values.
# The data is returned as a list.
def readBytes1 (filename):
  img_bin_data = []
  with open(filename, 'rb') as file:
    while True:
      b = file.read(1)
      if not b:
        break
      img_bin_data.append(int.from_bytes(b, byteorder='big'))
  while len(img_bin_data)%256!=0:
    img_bin_data.append(randint(0, 255))
  return img_bin_data

# The "readBytes2" function is used to read binary data from a file as bytes and add padding values if the file size is not in a specific range. 
# The bytes will be available as decimal values to use as pixel values.
# The file is returned as a tensor.
def readBytes2 (filename):
  img_bin_data = []
  with open(filename, 'rb') as file:
    while True:
      b = file.read(1)
      if not b:
        break
      img_bin_data.append(int.from_bytes(b, byteorder='big'))
  while len(img_bin_data)%512!=0:
    img_bin_data.append(randint(0, 255))
  return tf.convert_to_tensor(img_bin_data)

# The "grouper" function "Collects data into fixed-length chunks or blocks", for instance: grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx
# ref: https://stackoverflow.com/questions/3992735/python-generator-that-groups-another-iterable-into-groups-of-n
def grouper(iterable, n, fillvalue=None):
  args = [iter(iterable)] * n
  return zip_longest(fillvalue = fillvalue, *args)


def to1DArray_grayscale(img_bin_data,colormap):
  pixel_array = []
  for x, y in grouper(img_bin_data, 2) :
    new_pixel = colormap[x][y]
    pixel_array.append(new_pixel)
    
  return pixel_array


def saveImg (filename, data, size, img_type):
  try:
    image = Image.new(img_type, size)
    image.putdata(data)
    image.save(filename)
  except Exception as err:
    print(err)
    return 0
  return 1
