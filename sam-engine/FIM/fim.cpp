/**********************************************************************************/
/*                                                                                */
/* fim.cpp                                                                        */
/*                                                                                */
/**********************************************************************************/
/*                                                                                */
/*    Scorpion Anti-malware is a free Open Source AI-powered Anti-malware         */
/*    framework for Researchers.                                                  */
/*                                                                                */
/*    Copyright (c) 2024-present  (see AUTHORS.md).                               */
/*                                                                                */
/*    This program is free software: you can redistribute it and/or modify        */
/*    it under the terms of the GNU General Public License as published by        */
/*    the Free Software Foundation, either version 3 of the License, or           */
/*    (at your option) any later version.                                         */
/*                                                                                */
/*    This program is distributed in the hope that it will be useful,             */
/*    but WITHOUT ANY WARRANTY; without even the implied warranty of              */
/*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               */
/*    GNU General Public License for more details.                                */
/*                                                                                */
/*    You should have received a copy of the GNU General Public License           */
/*    along with this program.  If not, see <https://www.gnu.org/licenses/>.      */
/*                                                                                */
/**********************************************************************************/

#include "fim.hpp"

#include <filesystem>

namespace fs = std::filesystem;

#include <iostream>

FileIntegrityManagement::FileIntegrityManagement() : pModule(nullptr), pReadConfigFileFunc(nullptr), pIntegrityFunc(nullptr) {
    
}

FileIntegrityManagement::~FileIntegrityManagement() {
    if (FileIntegrityManagement::pIntegrityFunc) {
        // Release the reference to the function object
        Py_DECREF(FileIntegrityManagement::pIntegrityFunc);
    }

    if (FileIntegrityManagement::pReadConfigFileFunc) {
        // Release the reference to the function object
        Py_DECREF(FileIntegrityManagement::pReadConfigFileFunc);
    }

    if (FileIntegrityManagement::pModule) {
        // Release the reference to the module object
        Py_DECREF(FileIntegrityManagement::pModule);
    }
}

bool FileIntegrityManagement::init() {
    bool status {false};

    status = Py_IsInitialized();
    if (!status) {
        std::cout << "Error: Python interpreter is not initialized" << std::endl;
        return status;
    }

    // Append the directory containing the Python module to sys.path so that we can import it.
    PyObject* sysPath {PySys_GetObject((char*)"path")};

    if (!sysPath) {
        std::cout << "Error: Failed to get sys.path" << std::endl;
        PyErr_Print();
        return status;
    }

    if (!PyList_Check(sysPath)) {
        std::cout << "Error: sys.path is not a list" << std::endl;
        PyErr_Print();
        return status;
    }

    const char* fim_scripts_dir {SAM_FIM_SCRIPTS_DIR};

    if (!fs::exists(fim_scripts_dir)) {
        std::cout << "Error: PE engine scripts directory does not exist." << std::endl;
        return status;
    }

    // The fim_SCRIPTS_DIR macro is defined in the CMakeLists.txt file.
    PyList_Append(sysPath, PyUnicode_FromString(fim_scripts_dir));

    status = true;

    return status;
}

bool FileIntegrityManagement::read_config_file(std::vector<std::string>& dirs_buffer, std::vector<std::string>& freq_buffer, std::vector<std::string>& attributes_buffer) {
    
    const char* fim_config_filepath {SAM_FIM_SCRIPTS_DIR};

    // Append "/config.xml" to the path
    std::string config_file_path {fim_config_filepath + std::string("/config.xml")};

    bool status {false};

    status = Py_IsInitialized();
    if (!status) {
        std::cout << "Error: Python interpreter is not initialized" << std::endl;
        return status;
    }

    status = false;

    if (!FileIntegrityManagement::pModule) {
        FileIntegrityManagement::pModule = PyImport_ImportModule("fim");
        if (!FileIntegrityManagement::pModule || PyErr_Occurred()) {
            std::cout << "Error: Failed to import Python module" << std::endl;
            PyErr_Print();
            return status;
        }
    }

    if (!FileIntegrityManagement::pReadConfigFileFunc) {
        FileIntegrityManagement::pReadConfigFileFunc = PyObject_GetAttrString(pModule, "read_config_file");
        if (!FileIntegrityManagement::pReadConfigFileFunc || PyErr_Occurred()) {
            std::cout << "Error: Failed to get read_config_file function" << std::endl;
            PyErr_Print();
            return status;
        }
    }

    if (!PyCallable_Check(FileIntegrityManagement::pReadConfigFileFunc)) {
        std::cout << "Error: read_config_file is not callable" << std::endl;
        PyErr_Print();
        return status;
    }

    // The read_config_file requires 1 argument which is the path to the config file
    PyObject* pArgs {PyTuple_New(1)};

    if (!pArgs) {
        std::cout << "Error: Failed to create a new tuple" << std::endl;
        PyErr_Print();
        return status;
    }

    PyTuple_SetItem(pArgs, 0, PyUnicode_FromString(config_file_path.c_str()));

    PyObject* pReturn {PyObject_CallObject(FileIntegrityManagement::pReadConfigFileFunc, pArgs)};

    if (!pReturn) {
        std::cout << "Error: Failed to call the function" << std::endl;
        PyErr_Print();
        return status;
    }

    // The return value of the Python function is a tuple of 3 elements
    // The first element is a list of directories
    PyObject* pDirsListObj {PyTuple_GetItem(pReturn, 0)};

    // Make sure that the first element is a list
    if (!PyList_Check(pDirsListObj)) {
        std::cout << "Error: The first element is not a list" << std::endl;
        PyErr_Print();
        return status;
    }

    // Now we can iterate over the list and extract the directories 
    // and store them in the dirs_buffer vector
    dirs_buffer.clear();

    Py_ssize_t dirsListSize {PyList_Size(pDirsListObj)};

    // Convert Python list to C++ array
    for (Py_ssize_t i {0}; i < dirsListSize; i++) {
        PyObject* pItem {PyList_GetItem(pDirsListObj, i)};

        if (!pItem) {
            std::cout << "Error: A feature value found to be nullptr" << std::endl;
            PyErr_Print();
            return status;
        }

        if (!PyUnicode_Check(pItem)) {
            std::cout << "Error: The directory is not a string" << std::endl;
            PyErr_Print();
            return status;
        }

        dirs_buffer.emplace_back(PyUnicode_AsUTF8(pItem));
    }

    // The second element is the frequency
    PyObject* pFreqListObj {PyTuple_GetItem(pReturn, 1)};

    if (!pFreqListObj) {
        std::cout << "Error: Failed to get the second element" << std::endl;
        PyErr_Print();
        return status;
    }

    // Make sure that the second element is a list
    if (!PyList_Check(pFreqListObj)) {
        std::cout << "Error: The second element is not a list" << std::endl;
        PyErr_Print();
        return status;
    }

    // Now we can iterate over the list and extract the frequency
    freq_buffer.clear();

    Py_ssize_t freqListSize {PyList_Size(pFreqListObj)};

    // Convert Python list to C++ array
    for (Py_ssize_t i {0}; i < freqListSize; i++) {
        PyObject* pItem {PyList_GetItem(pFreqListObj, i)};

        if (!pItem) {
            std::cout << "Error: A frequency value found to be nullptr" << std::endl;
            PyErr_Print();
            return status;
        }

        if (!PyUnicode_Check(pItem)) {
            std::cout << "Error: The frequency is not a string" << std::endl;
            PyErr_Print();
            return status;
        }

        freq_buffer.emplace_back(PyUnicode_AsUTF8(pItem));
    }

    // The third element is a list of attributes

    PyObject* pAttributesListObj {PyTuple_GetItem(pReturn, 2)};

    // Make sure that the third element is a list
    if (!PyList_Check(pAttributesListObj)) {
        std::cout << "Error: The third element is not a list" << std::endl;
        PyErr_Print();
        return status;
    }

    // Now we can iterate over the list and extract the attributes
    attributes_buffer.clear();

    Py_ssize_t attributesListSize {PyList_Size(pAttributesListObj)};

    // Convert Python list to C++ array
    for (Py_ssize_t i {0}; i < attributesListSize; i++) {
        PyObject* pItem {PyList_GetItem(pAttributesListObj, i)};

        if (!pItem) {
            std::cout << "Error: An attribute value found to be nullptr" << std::endl;
            PyErr_Print();
            return status;
        }

        if (!PyUnicode_Check(pItem)) {
            std::cout << "Error: The attribute is not a string" << std::endl;
            PyErr_Print();
            return status;
        }

        attributes_buffer.emplace_back(PyUnicode_AsUTF8(pItem));
    }

    status = true;

    return status;
}

bool FileIntegrityManagement::integrity(const std::string& scan_dir, const std::vector<std::string>& freq, const std::vector<std::string>& attributes) {
    bool status {false};

    status = Py_IsInitialized();
    if (!status) {
        std::cout << "Error: Python interpreter is not initialized" << std::endl;
        return status;
    }

    status = false;

    if (!FileIntegrityManagement::pModule) {
        FileIntegrityManagement::pModule = PyImport_ImportModule("fim");
        if (!FileIntegrityManagement::pModule || PyErr_Occurred()) {
            std::cout << "Error: Failed to import Python module" << std::endl;
            PyErr_Print();
            return status;
        }
    }

    if (!FileIntegrityManagement::pIntegrityFunc) {
        FileIntegrityManagement::pIntegrityFunc = PyObject_GetAttrString(pModule, "integrity");
        if (!FileIntegrityManagement::pIntegrityFunc || PyErr_Occurred()) {
            std::cout << "Error: Failed to get integrity function" << std::endl;
            PyErr_Print();
            return status;
        }
    }

    if (!PyCallable_Check(FileIntegrityManagement::pIntegrityFunc)) {
        std::cout << "Error: integrity is not callable" << std::endl;
        PyErr_Print();
        return status;
    }

    // Create s string object to store the scan directory
    PyObject* pScanDir {PyUnicode_FromString(scan_dir.c_str())};

    if (!pScanDir) {
        std::cout << "Error: Failed to create a new string" << std::endl;
        PyErr_Print();
        return status;
    }

    // Create a list object to store the frequency
    PyObject* pFreqListObj {PyList_New(freq.size())};

    if (!pFreqListObj) {
        std::cout << "Error: Failed to create a new list" << std::endl;
        PyErr_Print();
        return status;
    }

    // Convert C++ array to Python list
    for (size_t i {0}; i < freq.size(); i++) {
        PyObject* pyStr = PyUnicode_FromString(freq.at(i).c_str());
        
        if (!pyStr) {
            std::cerr << "Error: Could not convert string to Python string" << std::endl;
            PyErr_Print();
            return status;
        }
        
        PyList_SetItem(pFreqListObj, i, pyStr);
    }

    // Create a list object to store the attributes
    PyObject* pAttributesListObj {PyList_New(attributes.size())};

    if (!pAttributesListObj) {
        std::cout << "Error: Failed to create a new list" << std::endl;
        PyErr_Print();
        return status;
    }

    // Convert C++ array to Python list
    for (size_t i {0}; i < attributes.size(); i++) {
        PyObject* pyStr = PyUnicode_FromString(attributes.at(i).c_str());
        
        if (!pyStr) {
            std::cerr << "Error: Could not convert string to Python string" << std::endl;
            PyErr_Print();
            return status;
        }
        
        PyList_SetItem(pAttributesListObj, i, pyStr);
    }

    // The integrity requires 3 argument which is the path to the config file
    PyObject* pArgs {PyTuple_New(3)};

    if (!pArgs) {
        std::cout << "Error: Failed to create a new tuple" << std::endl;
        PyErr_Print();
        return status;
    }

    PyTuple_SetItem(pArgs, 0, pScanDir);
    PyTuple_SetItem(pArgs, 1, pFreqListObj);
    PyTuple_SetItem(pArgs, 2, pAttributesListObj);

    PyObject* pReturn {PyObject_CallObject(FileIntegrityManagement::pIntegrityFunc, pArgs)};

    if (!pReturn) {
        std::cout << "Error: Failed to call the function" << std::endl;
        PyErr_Print();
        return status;
    }

    status = true;

    return status;
}

