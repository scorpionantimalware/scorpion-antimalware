#include "samengine.h"

#include "peengine.h"
#include "bytepixelengine.h"
#include "pathlgenerator.h"

#include <iostream>

SAMEngine::SAMEngine() : engine_thread(nullptr), mtx(nullptr) {
  Py_Initialize(); 
}

SAMEngine::~SAMEngine() {
  if (SAMEngine::mtx != nullptr) {
    delete SAMEngine::mtx;
  }

  if (SAMEngine::engine_thread != nullptr) {
    if (SAMEngine::engine_thread->joinable()) {
      SAMEngine::engine_thread->join();
    }
    delete SAMEngine::engine_thread;
  }

  // This is a no-op when called for a second time (without calling Py_Initialize() again first). 
  // Normally the return value is 0. If there were errors during finalization (flushing buffered data), -1 is returned.
  if (Py_FinalizeEx() < 0) {
      std::cerr << "Error: Failed to finalize Python interpreter" << std::endl;
      PyErr_Print();
  }
}

bool SAMEngine::scan() {
  bool status {false};

  if (SAMEngine::engine_thread != nullptr) {
    if (SAMEngine::engine_thread->joinable()) {
      return status;
    }
    delete SAMEngine::engine_thread;
  }

  SAMEngine::engine_thread = new std::thread(&SAMEngine::fire_scan, this);
  return status;
}

bool SAMEngine::fire_scan() {
  bool status {false};

  // Generate the .pathl file.
  size_t i {0};
  while (true) {
    PathlGenerator pathl_generator;

    // Generate paths for each scan area.
    status = pathl_generator.generate(SCAN_AREAS[i]);
    if (!status) {
      std::cout << "Error: Failed to generate .pathl file" << std::endl;
      return status;
    }

    // Next scan area.
    i++;

    // Break if we have generated paths for all scan areas.
    if (i >= sizeof(SCAN_AREAS) / sizeof(SCAN_AREAS[0])) {
      break;
    }
  }

  // Now pathl_generator is released.

  



  return status;
}
