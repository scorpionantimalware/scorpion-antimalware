#include "samengine.hpp"

#include "pepathlsgenerator.hpp"
#include "peengine.hpp"
#include "bytepixelengine.hpp"
#include "scanareasprocessor.hpp"

#include <fstream>

#include "staticannpeclassifier.hpp"
#include "staticcnnpeclassifier.hpp"

#include <iostream>

SAMEngine::SAMEngine() : engine_thread(nullptr), mtx(nullptr), scan_fire_callback(nullptr), scan_complete_callback(nullptr), new_file_callback(nullptr), status_callback(nullptr) {}

SAMEngine::~SAMEngine() {
  if (SAMEngine::mtx) {
    delete SAMEngine::mtx;
  }

  if (SAMEngine::engine_thread) {
    if (SAMEngine::engine_thread->joinable()) {
      SAMEngine::engine_thread->join();
    }
    delete SAMEngine::engine_thread;
  }
}

bool SAMEngine::scan() {
  bool status {false};

  if (SAMEngine::engine_thread) {
    status = SAMEngine::engine_thread->joinable();
    if (status) {
      std::cout << "Error: Engine thread is already running" << std::endl;
      status = false;
      return status;
    }
    delete SAMEngine::engine_thread;
  }

  SAMEngine::engine_thread = new std::thread(&SAMEngine::fire_scan, this);

  /*
    Detach the thread so that it can run independently of the main thread.

    Here in each scan, we will create a new thread so we do not need the current one.
  */
  SAMEngine::engine_thread->detach();

  status = true;

  return status;
}

bool SAMEngine::fire_scan() {
  if (SAMEngine::scan_fire_callback) {
    SAMEngine::scan_fire_callback();
  }

  bool status {false};

  // We must initialize the Python interpreter inside the thread that will use it.
  // See https://stackoverflow.com/a/61283805 for more information.
  status = Py_IsInitialized();
  if (!status) {
    Py_Initialize(); // If the Python interpreter is not initialized, initialize it.
    if (!Py_IsInitialized()) {
      std::cout << "Error: Failed to initialize Python interpreter"
                << std::endl;
      PyErr_Print();
      return status;
    }
  }

  ScanAreasProcessor scan_areas_processor;
  std::vector<std::string> scan_areas;
  status = scan_areas_processor.load_or_init(scan_areas);
  if (!status) {
    std::cout << "Error: Failed to load or initialize scan areas"
              << std::endl;
    return status;
  }

  if (scan_areas.empty()) {
    std::cout << "Info: No scan areas found" << std::endl;
    return status;
  }

  PEPathlsGenerator generator;

  // Generate the .pathl file.
  size_t i {0};
  while (i < scan_areas.size()) {

    // Generate paths for each scan area.
    status = generator.generate(scan_areas.at(i));
    if (!status) {
      std::cout << "Error: Failed to generate .pathl file" << std::endl;
      return status;
    }

    // Next scan area.
    i++;
  }

  // Now generator is released.
  std::cout << "Info: .pathl file generated" << std::endl;

  // Collect the paths from the .pathl file.
  // TODO: Don't open the full file at once. Load a batch and close the file.
  std::ifstream pe_pathls_file(PE_PATHLS_FILENAME);
  if (!pe_pathls_file.is_open()) {
    std::cout << "Error: Failed to open .pathl file" << std::endl;
    return status;
  }

  // Acquire the GIL before making Python C API calls.
  // See https://docs.python.org/3/c-api/init.hpptml#non-python-created-threads for more information.
  PyGILState_STATE gstate;
  gstate = PyGILState_Ensure();

  // Start the PE engine.
  PEEngine* pe_engine = new PEEngine();
  status = pe_engine->init();

  if (!status) {
    std::cout << "Error: Failed to initialize PE engine" << std::endl;
    return status;
  }

  BytePixelEngine* bp_engine = new BytePixelEngine();
  status = bp_engine->init();

  if (!status) {
    std::cout << "Error: Failed to initialize BytePixel Engine" << std::endl;
    return status;
  }

  // Start the StaticANNPEClassifier.
  StaticANNPEClassifier static_ann_pe_classifier;
  status = static_ann_pe_classifier.init();

  if (!status) {
    std::cout << "Error: Failed to initialize StaticANNPEClassifier" << std::endl;
    return status;
  }

 // Start the StaticCNNPEClassifier.
  StaticCNNPEClassifier static_cnn_pe_classifier;
  status = static_cnn_pe_classifier.init();

  if (!status) {
    std::cout << "Error: Failed to initialize StaticCNNPEClassifier" << std::endl;
    return status;
  }

  // Main loop.
  std::string pe_sample;
  while (std::getline(pe_pathls_file, pe_sample)) {
    std::cout << "Info: Scanning " << pe_sample << std::endl;

    /*
      This ID is used to get the file entry from the table inside the GUI.
    */
    int new_file_id {-1};
    if (SAMEngine::new_file_callback) {
      new_file_id = SAMEngine::new_file_callback(pe_sample);
    }

    // Get the PE features of the file.
    std::vector<float> pe_features;

    status = pe_engine->get_pe_features(pe_sample, pe_features);

    if (!status) {
      std::cout << "Error: Failed to get PE features of " << pe_sample << std::endl;
      continue;
    }

    std::vector<float> bp_features;

    status = bp_engine->get_byte_pixel_features(pe_sample, bp_features);

    if (!status) {
      std::cout << "Error: Failed to get Pixel features of " << pe_sample << std::endl;
      continue;
    }

    // Classify the PE file.
    float annoutput {-1.0f};
    
    status = static_ann_pe_classifier.classify(pe_features, annoutput);

    if (!status) {
      std::cout << "Error: ANN failed to classify " << pe_sample << std::endl;
      continue;
    }

    // Classify the PE file for CNN.
    float cnnoutput {-1.0f};

    status = static_cnn_pe_classifier.classify(bp_features, cnnoutput);

    if (!status) {
      std::cout << "Error: CNN failed to classify " << pe_sample << std::endl;
      continue;
    }

    std::cout << "ANN-Info: " << pe_sample << " is classified as " << ((annoutput < 0.5f) ? "Bengin" : "Malware") << " with confidence " << annoutput << std::endl;
    std::cout << "CNN-Info: " << pe_sample << " is classified as " << ((cnnoutput < 0.5f) ? "Bengin" : "Malware") << " with confidence " << cnnoutput << std::endl;

    /*
      This is the static voting mechanism.
    */
    float prediction {(annoutput + cnnoutput) / 2.0f};

    if (SAMEngine::status_callback) {
      SAMEngine::status_callback(new_file_id, prediction);
    }
  }

  // Delete the PE engine as we will release the interpreter.
  delete pe_engine;
  delete bp_engine;

  /* Release the thread. No Python API allowed beyond this point. */
  PyGILState_Release(gstate);

  pe_pathls_file.close();

  status = Py_IsInitialized();
  if (!status) {
    std::cout << "Error: Python interpreter is not initialized" << std::endl;
    return status;
  }

  // Release the Python interpreter.
  // This is a no-op when called for a second time (without calling
  // Py_Initialize() again first). Normally the return value is 0. If there
  // were errors during finalization (flushing buffered data), -1 is returned.
  if (Py_FinalizeEx() < 0) {
    std::cout << "Error: Failed to finalize Python interpreter" << std::endl;
    PyErr_Print();
  }

  if (SAMEngine::scan_complete_callback) {
    SAMEngine::scan_complete_callback();
  }

  status = true;

  return status;
}

void SAMEngine::hook_scan_fire_callback(ScanFireCallback_t callback) {
  SAMEngine::scan_fire_callback = callback;
}

void SAMEngine::hook_scan_complete_callback(ScanCompleteCallback_t callback) {
  SAMEngine::scan_complete_callback = callback;
}

void SAMEngine::hook_new_file_callback(NewFileCallback_t callback) {
  SAMEngine::new_file_callback = callback;
}

void SAMEngine::hook_status_callback(StatusCallback_t callback) {
  SAMEngine::status_callback = callback;
}
