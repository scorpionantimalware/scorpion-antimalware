#include "samengine.h"

#include "pathlgenerator.h"
#include "peengine.h"
#include "bytepixelengine.h"

#include <fstream>

#include "staticannpeclassifier.h"

#include <iostream>

SAMEngine::SAMEngine() : engine_thread(nullptr), mtx(nullptr) {}

SAMEngine::~SAMEngine() {
  if (SAMEngine::mtx) {
    delete SAMEngine::mtx;
  }

  if (SAMEngine::engine_thread) {
    if (SAMEngine::engine_thread->joinable()) {
      SAMEngine::engine_thread->join();
    }
    delete SAMEngine::engine_thread;
  }

  if (Py_IsInitialized()) {
    // This is a no-op when called for a second time (without calling Py_Initialize() again first). 
    // Normally the return value is 0. If there were errors during finalization (flushing buffered data), -1 is returned.
    if (Py_FinalizeEx() < 0) {
        std::cout << "Error: Failed to finalize Python interpreter" << std::endl;
        PyErr_Print();
    }
  }
}

bool SAMEngine::scan() {
  bool status {false};

  status = Py_IsInitialized();
  if (!status) {
    Py_Initialize(); // If the Python interpreter is not initialized, initialize it.
    if (!Py_IsInitialized()) {
      std::cout << "Error: Failed to initialize Python interpreter" << std::endl;
      PyErr_Print();
      return status;
    }
  }

  if (SAMEngine::engine_thread) {
    status = SAMEngine::engine_thread->joinable();
    if (status) {
      std::cout << "Error: Engine thread is already running" << std::endl;
      status = false;
      return status;
    }
    delete SAMEngine::engine_thread;
  }

  // SAMEngine::engine_thread = new std::thread(&SAMEngine::fire_scan, this);
  SAMEngine::fire_scan();

  return status;
}

bool SAMEngine::fire_scan() {
  bool status {false};

  // Generate the .pathl file.
  size_t i {0};
  while (true) {
    PathlGenerator pathl_generator;

    // Generate paths for each scan area.
    status = pathl_generator.generate(SCAN_AREAS[i]);
    if (!status) {
      std::cout << "Error: Failed to generate .pathl file" << std::endl;
      return status;
    }

    // Next scan area.
    i++;

    // Break if we have generated paths for all scan areas.
    if (i >= sizeof(SCAN_AREAS) / sizeof(SCAN_AREAS[0])) {
      break;
    }
  }

  // Now pathl_generator is released.
  std::cout << "Info: .pathl file generated" << std::endl;

  // Collect the paths from the .pathl file.
  // TODO: Don't open the full file at once. Load a batch and close the file.
  std::ifstream scan_area(PATHL_FILENAME);
  if (!scan_area.is_open()) {
    std::cout << "Error: Failed to open .pathl file" << std::endl;
    return status;
  }

  // Acquire the GIL before making Python C API calls.
  // See https://docs.python.org/3/c-api/init.html#non-python-created-threads for more information.
  PyGILState_STATE gstate;
  gstate = PyGILState_Ensure();

  // Start the PE engine.
  PEEngine pe_engine;
  status = pe_engine.init();

  if (!status) {
    std::cout << "Error: Failed to initialize PE engine" << std::endl;
    return status;
  }

  // Start the StaticANNPEClassifier.
  StaticANNPEClassifier static_ann_pe_classifier;
  status = static_ann_pe_classifier.init();

  if (!status) {
    std::cout << "Error: Failed to initialize StaticANNPEClassifier" << std::endl;
    return status;
  }

  // Main loop.
  std::string pe_sample;
  while (std::getline(scan_area, pe_sample)) {
    std::cout << "Info: Scanning " << pe_sample << std::endl;

    // Get the PE features of the file.
    std::vector<float> pe_features;

    status = pe_engine.get_pe_features(pe_sample, pe_features);

    if (!status) {
      std::cout << "Error: Failed to get PE features of " << pe_sample << std::endl;
      continue;
    }

    // Classify the PE file.
    float output {-1.0f};
    status = static_ann_pe_classifier.classify(pe_features, output);

    if (!status) {
      std::cout << "Error: Failed to classify " << pe_sample << std::endl;
      continue;
    }

    std::cout << "Info: " << pe_sample << " is classified as " << ((output < 0.5f) ? "Bengin" : "Malware") << std::endl;
  }

  /* Release the thread. No Python API allowed beyond this point. */
  PyGILState_Release(gstate);

  scan_area.close();

  status = true;

  return status;
}
