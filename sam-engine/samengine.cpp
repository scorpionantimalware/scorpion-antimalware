/**
 *                        بِسْمِ اللَّهِ الرَّحْمَنِ الرَّحِيمِ
 * 
 * samenigne.cpp - The main engine of the Scorpion Anti-malware.
 * 
 * Copyright (c) 2024-present Scorpion Anti-malware (see AUTHORS.md).
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 */

#include "samengine.hpp"

#include "pepathlsgenerator.hpp"
#include "peengine.hpp"
#include "bytepixelengine.hpp"
#include "scanareasprocessor.hpp"

#include <fstream>

#include "staticannpeclassifier.hpp"
#include "staticcnnpeclassifier.hpp"

#include "pepathlsmonitor.hpp"

#include <iostream>

#define MAX_CONSUMERS 10

ScanFireCallback_t scan_fire_callback {nullptr};
ScanCompleteCallback_t scan_complete_callback {nullptr};
NewFileCallback_t new_file_callback {nullptr};
StatusCallback_t status_callback {nullptr};

#ifdef SAM_ENGINE_ENABLE_UI_THREAD
std::thread* engine_thread {nullptr};
#endif // SAM_ENGINE_ENABLE_UI_THREAD

#ifdef SAM_ENGINE_ENABLE_UI_THREAD
/**
 * @brief Start the scan process
 * 
 * @note This function is the entry point for the scan process. This 
 *       function is Multi-threaded.
 * 
 * @note This function is a wrapper for the fire_scan() function to be
 *      called in a separate thread.
 * 
 * @todo This function raises the below error:
 *       HEAP CORRUPTION DETECTED: after Normal block (#208) at 
 *       0X000001A468C07620. CRT detected that the application wrote to
 *       memory after the end of the heap buffer (resolved).
*/
void fire_scan_thread_wrapper();
#endif // SAM_ENGINE_ENABLE_UI_THREAD

bool fire_scan();

void fire_classifiers(PEPathlsMonitor& monitor, 
                      std::mutex &new_file_callback_mtx, 
                      std::mutex &status_callback_mtx, 
                      PEEngine& pe_engine, 
                      BytePixelEngine& bp_engine, 
                      StaticANNPEClassifier& static_ann_pe_classifier, 
                      StaticCNNPEClassifier& static_cnn_pe_classifier);

bool sam_engine_scan() {
  bool status {false};

#ifdef SAM_ENGINE_ENABLE_UI_THREAD
  std::cout << "Info: Running the engine in a separate thread" << std::endl;
  if (engine_thread) {
    status = engine_thread->joinable();
    if (status) {
      std::cout << "Error: Engine thread is already running" << std::endl;
      status = false;
      return status;
    }
    delete engine_thread;
  }

  engine_thread = new std::thread(&fire_scan_thread_wrapper);

  /*
    Detach the thread so that it can run independently of the main thread.

    Here in each scan, we will create a new thread so we do not need the current one.
  */
  engine_thread->detach();
  
#else
  std::cout << "Info: Running the engine in the main thread" << std::endl;
  status = fire_scan();
  if (!status) {
    std::cout << "Error: Something went wrong while scanning" << std::endl;
    return status;
  }
#endif // SAM_ENGINE_ENABLE_UI_THREAD

#ifdef SAM_ENGINE_ENABLE_UI_THREAD
  if (engine_thread) {
    if (engine_thread->joinable()) {
      engine_thread->join();
    }
    delete engine_thread;
  }
#endif // SAM_ENGINE_ENABLE_UI_THREAD
  
  status = true;

  return status;
}

#ifdef SAM_ENGINE_ENABLE_UI_THREAD
void fire_scan_thread_wrapper() {
  bool status {false};

  status = fire_scan();
  if (!status) {
    std::cout << "Error: Something went wrong while scanning" << std::endl;
  }
}
#endif // SAM_ENGINE_ENABLE_UI_THREAD

bool fire_scan() {
  if (scan_fire_callback) {
    scan_fire_callback();
  }

  bool status {false};

  // We must initialize the Python interpreter inside the thread that will use it.
  // See https://stackoverflow.com/a/61283805 for more information.
  status = Py_IsInitialized();
  if (!status) {
    Py_Initialize(); // If the Python interpreter is not initialized, initialize it.
    if (!Py_IsInitialized()) {
      std::cout << "Error: Failed to initialize Python interpreter"
                << std::endl;
      PyErr_Print();
      if (scan_complete_callback) {
        scan_complete_callback();
      }
      return status;
    }
  }

  ScanAreasProcessor scan_areas_processor;
  std::vector<std::string> scan_areas;
  status = scan_areas_processor.load_or_init(scan_areas);
  if (!status) {
    std::cout << "Error: Failed to load or initialize scan areas"
              << std::endl;
    if (scan_complete_callback) {
      scan_complete_callback();
    }
    return status;
  }

  if (scan_areas.empty()) {
    std::cout << "Info: No scan areas found" << std::endl;
    if (scan_complete_callback) {
      scan_complete_callback();
    }
    return status;
  }

  PEPathlsGenerator generator;

  // Generate the .pathl file.
  size_t i {0};
  while (i < scan_areas.size()) {

    // Generate paths for each scan area.
    status = generator.generate(scan_areas.at(i));
    if (!status) {
      std::cout << "Error: Failed to generate .pathl file" << std::endl;
      if (scan_complete_callback) {
        scan_complete_callback();
      }
      return status;
    }

    // Next scan area.
    i++;
  }

  // Now the generator is released.
  std::cout << "Info: .pathl file generated" << std::endl;

  // Collect the paths from the .pathl file.
  // TODO: Don't open the full file at once. Load a batch and close the file.
  std::ifstream pe_pathls_file(PE_PATHLS_FILENAME);
  if (!pe_pathls_file.is_open()) {
    std::cout << "Error: Failed to open .pathl file" << std::endl;
    if (scan_complete_callback) {
      scan_complete_callback();
    }
    return status;
  }

  // Start the PE engine.
  PEEngine* pe_engine = new PEEngine();
  status = pe_engine->init();

  if (!status) {
    std::cout << "Error: Failed to initialize PE engine" << std::endl;
    if (scan_complete_callback) {
      scan_complete_callback();
    }
    return status;
  }

  BytePixelEngine* bp_engine = new BytePixelEngine();
  status = bp_engine->init();

  if (!status) {
    std::cout << "Error: Failed to initialize BytePixel Engine" << std::endl;
    if (scan_complete_callback) {
      scan_complete_callback();
    }
    return status;
  }

  // Start the StaticANNPEClassifier.
  StaticANNPEClassifier static_ann_pe_classifier;
  status = static_ann_pe_classifier.init();

  if (!status) {
    std::cout << "Error: Failed to initialize StaticANNPEClassifier" << std::endl;
    if (scan_complete_callback) {
      scan_complete_callback();
    }
    return status;
  }

 // Start the StaticCNNPEClassifier.
  StaticCNNPEClassifier static_cnn_pe_classifier;
  status = static_cnn_pe_classifier.init();

  if (!status) {
    std::cout << "Error: Failed to initialize StaticCNNPEClassifier" << std::endl;
    if (scan_complete_callback) {
      scan_complete_callback();
    }
    return status;
  }

  /**
  * Now we need to release the GIL to enable the consumers to use the Python interpreter. We
  * Can't use the Python interpreter here again until acquiring the GIL again.
  * 
  * @note Check https://stackoverflow.com/a/29725222.
  * 
  * @note Check https://docs.python.org/3/c-api/init.html#releasing-the-gil-from-extension-code.
  * 
  * @note You can use the following MACRO @c Py_BEGIN_ALLOW_THREADS
  * 
  */
  PyThreadState *_save;

  _save = PyEval_SaveThread();

    PEPathlsMonitor monitor;
    std::mutex new_file_callback_mtx;
    std::mutex status_callback_mtx;

  // Create consumer threads
   std::vector<std::thread> consumers;
   for (size_t j {0}; j < MAX_CONSUMERS; ++j) {
     consumers.emplace_back(fire_classifiers, std::ref(monitor),
                            std::ref(new_file_callback_mtx), 
                            std::ref(status_callback_mtx), 
                            std::ref(*pe_engine),
                            std::ref(*bp_engine),
                            std::ref(static_ann_pe_classifier),
                            std::ref(static_cnn_pe_classifier));
   }

  // Main loop.
  std::string pe_pathl_buffer;
  while (std::getline(pe_pathls_file, pe_pathl_buffer)) {
     monitor.add_pe_pathl(pe_pathl_buffer);
  }

  // Notify consumers that no more files will be added
   monitor.set_done();

  // Join consumer threads
   for (auto& consumer : consumers) {
       consumer.join();
   }

   /**
    * Now we need to acquire the GIL again to enable this engine thread to use the
    * interpreter.
    *
    * @note You can use the following MACRO @c Py_END_ALLOW_THREADS
    *
    * @note The interpreter is used again inside destructors of pe_engine and 
    *       bp_engine.
    *
    */
  PyEval_RestoreThread(_save);

  // Delete the PE engine as we will release the interpreter.
  delete pe_engine;
  delete bp_engine;

  pe_pathls_file.close();

  status = Py_IsInitialized();
  if (!status) {
    std::cout << "Error: Python interpreter is not initialized" << std::endl;
    if (scan_complete_callback) {
      scan_complete_callback();
    }
    return status;
  }

  // Release the Python interpreter.
  // This is a no-op when called for a second time (without calling
  // Py_Initialize() again first). Normally the return value is 0. If there
  // were errors during finalization (flushing buffered data), -1 is returned.
  if (Py_FinalizeEx() < 0) {
    std::cout << "Error: Failed to finalize Python interpreter" << std::endl;
    PyErr_Print();
  }

  if (scan_complete_callback) {
    scan_complete_callback();
  }

  status = true;

  return status;
}

void fire_classifiers(PEPathlsMonitor &monitor,
                      std::mutex &new_file_callback_mtx,
                      std::mutex &status_callback_mtx, 
                      PEEngine &pe_engine,
                      BytePixelEngine &bp_engine,
                      StaticANNPEClassifier &static_ann_pe_classifier,
                      StaticCNNPEClassifier &static_cnn_pe_classifier) {
  std::string pathl_buffer;
  while (monitor.get_pe_pathl(pathl_buffer)) {
    std::cout << "Info: Scanning " << pathl_buffer << std::endl;

    bool status {false};

    /*
      This ID is used to get the file entry from the table inside the GUI.
    */
    int new_file_id {-1};
    if (new_file_callback) {
      {
        // The status callback modifies the GUI so we want to make sure that
        // only one thread does it at a time.
        std::lock_guard<std::mutex> lock(new_file_callback_mtx);
        new_file_id = new_file_callback(pathl_buffer);
      }
      if (new_file_id == -1) {
        std::cout << "Error: Failed to get the new file ID" << std::endl;
        continue;
      }
    }

    // Acquire the GIL before making Python C API calls.
    // See
    // https://docs.python.org/3/c-api/init.html#non-python-created-threads
    // for more information.
    // 
    // This is similar to a mutex, however, this is specific to the interpreter to protect it as it is not thread-safe.
    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();

    // Get the PE features of the file.
    std::vector<float> pe_features;

    // TODO: Exception thrown at 0x00007FFC039CAB89 in scorpion-antimalware.exe: Microsoft C++ exception: nanobind::builtin_exception at memory location 0x000000996C1FEAF0.
    status = pe_engine.get_pe_features(pathl_buffer, pe_features);

    if (!status) {
      std::cout << "Error: Failed to get PE features of " << pathl_buffer << std::endl;
      continue;
    }

    std::vector<float> bp_features;

    status = bp_engine.get_byte_pixel_features(pathl_buffer, bp_features);

    if (!status) {
      std::cout << "Error: Failed to get Pixel features of " << pathl_buffer << std::endl;
      continue;
    }

    /* Release the thread. No Python API allowed beyond this point. */
    PyGILState_Release(gstate);

    // Classify the PE file.
    float annoutput {-1.0f};
    
    status = static_ann_pe_classifier.classify(pe_features, annoutput);

    if (!status || annoutput == -1.0f) {
      std::cout << "Error: ANN failed to classify " << pathl_buffer << std::endl;
      continue;
    }

    // Classify the PE file for CNN.
    float cnnoutput {-1.0f};

    status = static_cnn_pe_classifier.classify(bp_features, cnnoutput);

    if (!status || cnnoutput == -1.0f) {
      std::cout << "Error: CNN failed to classify " << pathl_buffer << std::endl;
      continue;
    }

    std::cout << "ANN-Info: " << pathl_buffer << " is classified as " << ((annoutput < 0.5f) ? "Bengin" : "Malware") << " with confidence " << annoutput << std::endl;
    std::cout << "CNN-Info: " << pathl_buffer << " is classified as " << ((cnnoutput < 0.5f) ? "Bengin" : "Malware") << " with confidence " << cnnoutput << std::endl;

    /*
      This is the static voting mechanism.
    */
    float prediction {(annoutput + cnnoutput) * 0.5f};

    if (status_callback) {
      // The status callback modifies the GUI so we want to make sure that 
      // only one thread does it at a time.
      std::lock_guard<std::mutex> lock(status_callback_mtx);
      status_callback(new_file_id, prediction);
    }
  }
}

void hook_scan_fire_callback(ScanFireCallback_t callback) {
  scan_fire_callback = callback;
}

void hook_scan_complete_callback(ScanCompleteCallback_t callback) {
  scan_complete_callback = callback;
}

void hook_new_file_callback(NewFileCallback_t callback) {
  new_file_callback = callback;
}

void hook_status_callback(StatusCallback_t callback) {
  status_callback = callback;
}
