#include "samengine.h"

#include "peengine.h"
#include "bytepixelengine.h"
#include "pathlgenerator.h"

#include <iostream>

SAMEngine::SAMEngine() : engine_thread(nullptr), mtx(nullptr) {}

SAMEngine::~SAMEngine() {
  if (SAMEngine::mtx) {
    delete SAMEngine::mtx;
  }

  if (SAMEngine::engine_thread) {
    if (SAMEngine::engine_thread->joinable()) {
      SAMEngine::engine_thread->join();
    }
    delete SAMEngine::engine_thread;
  }

  if (!Py_IsInitialized()) {
    std::cout << "Warning: Can not finalize Python interpreter because it is not initialized." << std::endl;
    return;
  }

  // This is a no-op when called for a second time (without calling Py_Initialize() again first). 
  // Normally the return value is 0. If there were errors during finalization (flushing buffered data), -1 is returned.
  if (Py_FinalizeEx() < 0) {
      std::cout << "Error: Failed to finalize Python interpreter" << std::endl;
      PyErr_Print();
  }
}

bool SAMEngine::scan() {
  bool status {false};

  status = Py_IsInitialized();
  if (!status) {
    Py_Initialize(); // If the Python interpreter is not initialized, initialize it.
    if (!Py_IsInitialized()) {
      std::cout << "Error: Failed to initialize Python interpreter" << std::endl;
      PyErr_Print();
      return status;
    }
  }

  if (SAMEngine::engine_thread) {
    status = SAMEngine::engine_thread->joinable();
    if (status) {
      std::cout << "Error: Engine thread is already running" << std::endl;
      status = false;
      return status;
    }
    delete SAMEngine::engine_thread;
  }

  SAMEngine::engine_thread = new std::thread(&SAMEngine::fire_scan, this);
  return status;
}

bool SAMEngine::fire_scan() {
  bool status {false};

  // Generate the .pathl file.
  size_t i {0};
  while (true) {
    PathlGenerator pathl_generator;

    // Generate paths for each scan area.
    status = pathl_generator.generate(SCAN_AREAS[i]);
    if (!status) {
      std::cout << "Error: Failed to generate .pathl file" << std::endl;
      return status;
    }

    // Next scan area.
    i++;

    // Break if we have generated paths for all scan areas.
    if (i >= sizeof(SCAN_AREAS) / sizeof(SCAN_AREAS[0])) {
      break;
    }
  }

  // Now pathl_generator is released.
  std::cout << "Info: .pathl file generated" << std::endl;
  



  return status;
}
